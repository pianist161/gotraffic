"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@iconify";
exports.ids = ["vendor-chunks/@iconify"];
exports.modules = {

/***/ "(rsc)/./node_modules/@iconify/react/dist/iconify.js":
/*!*****************************************************!*\
  !*** ./node_modules/@iconify/react/dist/iconify.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Icon: () => (/* binding */ Icon),
/* harmony export */   InlineIcon: () => (/* binding */ InlineIcon),
/* harmony export */   _api: () => (/* binding */ _api),
/* harmony export */   addAPIProvider: () => (/* binding */ addAPIProvider),
/* harmony export */   addCollection: () => (/* binding */ addCollection),
/* harmony export */   addIcon: () => (/* binding */ addIcon),
/* harmony export */   buildIcon: () => (/* binding */ buildIcon),
/* harmony export */   calculateSize: () => (/* binding */ calculateSize),
/* harmony export */   getIcon: () => (/* binding */ getIcon),
/* harmony export */   iconLoaded: () => (/* binding */ iconLoaded),
/* harmony export */   listIcons: () => (/* binding */ listIcons),
/* harmony export */   loadIcon: () => (/* binding */ loadIcon),
/* harmony export */   loadIcons: () => (/* binding */ loadIcons),
/* harmony export */   replaceIDs: () => (/* binding */ replaceIDs),
/* harmony export */   setCustomIconLoader: () => (/* binding */ setCustomIconLoader),
/* harmony export */   setCustomIconsLoader: () => (/* binding */ setCustomIconsLoader)
/* harmony export */ });
/* harmony import */ var react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-server-dom-webpack/server */ "(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-webpack-server.js");

const Icon = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call Icon() from the server but Icon is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"Icon",
);const InlineIcon = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call InlineIcon() from the server but InlineIcon is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"InlineIcon",
);const _api = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call _api() from the server but _api is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"_api",
);const addAPIProvider = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call addAPIProvider() from the server but addAPIProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"addAPIProvider",
);const addCollection = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call addCollection() from the server but addCollection is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"addCollection",
);const addIcon = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call addIcon() from the server but addIcon is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"addIcon",
);const buildIcon = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call buildIcon() from the server but buildIcon is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"buildIcon",
);const calculateSize = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call calculateSize() from the server but calculateSize is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"calculateSize",
);const getIcon = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call getIcon() from the server but getIcon is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"getIcon",
);const iconLoaded = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call iconLoaded() from the server but iconLoaded is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"iconLoaded",
);const listIcons = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call listIcons() from the server but listIcons is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"listIcons",
);const loadIcon = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call loadIcon() from the server but loadIcon is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"loadIcon",
);const loadIcons = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call loadIcons() from the server but loadIcons is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"loadIcons",
);const replaceIDs = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call replaceIDs() from the server but replaceIDs is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"replaceIDs",
);const setCustomIconLoader = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call setCustomIconLoader() from the server but setCustomIconLoader is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"setCustomIconLoader",
);const setCustomIconsLoader = (0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call setCustomIconsLoader() from the server but setCustomIconsLoader is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\enock\\TS\\node_modules\\@iconify\\react\\dist\\iconify.js",
"setCustomIconsLoader",
);

/***/ }),

/***/ "(ssr)/./node_modules/@iconify/react/dist/iconify.js":
/*!*****************************************************!*\
  !*** ./node_modules/@iconify/react/dist/iconify.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Icon: () => (/* binding */ Icon),\n/* harmony export */   InlineIcon: () => (/* binding */ InlineIcon),\n/* harmony export */   _api: () => (/* binding */ _api),\n/* harmony export */   addAPIProvider: () => (/* binding */ addAPIProvider),\n/* harmony export */   addCollection: () => (/* binding */ addCollection),\n/* harmony export */   addIcon: () => (/* binding */ addIcon),\n/* harmony export */   buildIcon: () => (/* binding */ iconToSVG),\n/* harmony export */   calculateSize: () => (/* binding */ calculateSize),\n/* harmony export */   getIcon: () => (/* binding */ getIcon),\n/* harmony export */   iconLoaded: () => (/* binding */ iconLoaded),\n/* harmony export */   listIcons: () => (/* binding */ listIcons),\n/* harmony export */   loadIcon: () => (/* binding */ loadIcon),\n/* harmony export */   loadIcons: () => (/* binding */ loadIcons),\n/* harmony export */   replaceIDs: () => (/* binding */ replaceIDs),\n/* harmony export */   setCustomIconLoader: () => (/* binding */ setCustomIconLoader),\n/* harmony export */   setCustomIconsLoader: () => (/* binding */ setCustomIconsLoader)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ Icon,InlineIcon,_api,addAPIProvider,addCollection,addIcon,buildIcon,calculateSize,getIcon,iconLoaded,listIcons,loadIcon,loadIcons,replaceIDs,setCustomIconLoader,setCustomIconsLoader auto */ \nconst defaultIconDimensions = Object.freeze({\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n});\nconst defaultIconTransformations = Object.freeze({\n    rotate: 0,\n    vFlip: false,\n    hFlip: false\n});\nconst defaultIconProps = Object.freeze({\n    ...defaultIconDimensions,\n    ...defaultIconTransformations\n});\nconst defaultExtendedIconProps = Object.freeze({\n    ...defaultIconProps,\n    body: \"\",\n    hidden: false\n});\nfunction mergeIconTransformations(obj1, obj2) {\n    const result = {};\n    if (!obj1.hFlip !== !obj2.hFlip) {\n        result.hFlip = true;\n    }\n    if (!obj1.vFlip !== !obj2.vFlip) {\n        result.vFlip = true;\n    }\n    const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n    if (rotate) {\n        result.rotate = rotate;\n    }\n    return result;\n}\nfunction mergeIconData(parent, child) {\n    const result = mergeIconTransformations(parent, child);\n    for(const key in defaultExtendedIconProps){\n        if (key in defaultIconTransformations) {\n            if (key in parent && !(key in result)) {\n                result[key] = defaultIconTransformations[key];\n            }\n        } else if (key in child) {\n            result[key] = child[key];\n        } else if (key in parent) {\n            result[key] = parent[key];\n        }\n    }\n    return result;\n}\nfunction getIconsTree(data, names) {\n    const icons = data.icons;\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    const resolved = /* @__PURE__ */ Object.create(null);\n    function resolve(name) {\n        if (icons[name]) {\n            return resolved[name] = [];\n        }\n        if (!(name in resolved)) {\n            resolved[name] = null;\n            const parent = aliases[name] && aliases[name].parent;\n            const value = parent && resolve(parent);\n            if (value) {\n                resolved[name] = [\n                    parent\n                ].concat(value);\n            }\n        }\n        return resolved[name];\n    }\n    Object.keys(icons).concat(Object.keys(aliases)).forEach(resolve);\n    return resolved;\n}\nfunction internalGetIconData(data, name, tree) {\n    const icons = data.icons;\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    let currentProps = {};\n    function parse(name2) {\n        currentProps = mergeIconData(icons[name2] || aliases[name2], currentProps);\n    }\n    parse(name);\n    tree.forEach(parse);\n    return mergeIconData(data, currentProps);\n}\nfunction parseIconSet(data, callback) {\n    const names = [];\n    if (typeof data !== \"object\" || typeof data.icons !== \"object\") {\n        return names;\n    }\n    if (data.not_found instanceof Array) {\n        data.not_found.forEach((name)=>{\n            callback(name, null);\n            names.push(name);\n        });\n    }\n    const tree = getIconsTree(data);\n    for(const name in tree){\n        const item = tree[name];\n        if (item) {\n            callback(name, internalGetIconData(data, name, item));\n            names.push(name);\n        }\n    }\n    return names;\n}\nconst optionalPropertyDefaults = {\n    provider: \"\",\n    aliases: {},\n    not_found: {},\n    ...defaultIconDimensions\n};\nfunction checkOptionalProps(item, defaults) {\n    for(const prop in defaults){\n        if (prop in item && typeof item[prop] !== typeof defaults[prop]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction quicklyValidateIconSet(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return null;\n    }\n    const data = obj;\n    if (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") {\n        return null;\n    }\n    if (!checkOptionalProps(obj, optionalPropertyDefaults)) {\n        return null;\n    }\n    const icons = data.icons;\n    for(const name in icons){\n        const icon = icons[name];\n        if (// Name cannot be empty\n        !name || // Must have body\n        typeof icon.body !== \"string\" || // Check other props\n        !checkOptionalProps(icon, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    for(const name in aliases){\n        const icon = aliases[name];\n        const parent = icon.parent;\n        if (// Name cannot be empty\n        !name || // Parent must be set and point to existing icon\n        typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || // Check other props\n        !checkOptionalProps(icon, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    return data;\n}\nconst matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\nconst stringToIcon = (value, validate, allowSimpleName, provider = \"\")=>{\n    const colonSeparated = value.split(\":\");\n    if (value.slice(0, 1) === \"@\") {\n        if (colonSeparated.length < 2 || colonSeparated.length > 3) {\n            return null;\n        }\n        provider = colonSeparated.shift().slice(1);\n    }\n    if (colonSeparated.length > 3 || !colonSeparated.length) {\n        return null;\n    }\n    if (colonSeparated.length > 1) {\n        const name2 = colonSeparated.pop();\n        const prefix = colonSeparated.pop();\n        const result = {\n            // Allow provider without '@': \"provider:prefix:name\"\n            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n            prefix,\n            name: name2\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    const name = colonSeparated[0];\n    const dashSeparated = name.split(\"-\");\n    if (dashSeparated.length > 1) {\n        const result = {\n            provider,\n            prefix: dashSeparated.shift(),\n            name: dashSeparated.join(\"-\")\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    if (allowSimpleName && provider === \"\") {\n        const result = {\n            provider,\n            prefix: \"\",\n            name\n        };\n        return validate && !validateIconName(result, allowSimpleName) ? null : result;\n    }\n    return null;\n};\nconst validateIconName = (icon, allowSimpleName)=>{\n    if (!icon) {\n        return false;\n    }\n    return !!// Check name: cannot be empty\n    ((allowSimpleName && icon.prefix === \"\" || !!icon.prefix) && !!icon.name);\n};\nconst dataStorage = /* @__PURE__ */ Object.create(null);\nfunction newStorage(provider, prefix) {\n    return {\n        provider,\n        prefix,\n        icons: /* @__PURE__ */ Object.create(null),\n        missing: /* @__PURE__ */ new Set()\n    };\n}\nfunction getStorage(provider, prefix) {\n    const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));\n    return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\nfunction addIconSet(storage, data) {\n    if (!quicklyValidateIconSet(data)) {\n        return [];\n    }\n    return parseIconSet(data, (name, icon)=>{\n        if (icon) {\n            storage.icons[name] = icon;\n        } else {\n            storage.missing.add(name);\n        }\n    });\n}\nfunction addIconToStorage(storage, name, icon) {\n    try {\n        if (typeof icon.body === \"string\") {\n            storage.icons[name] = {\n                ...icon\n            };\n            return true;\n        }\n    } catch (err) {}\n    return false;\n}\nfunction listIcons(provider, prefix) {\n    let allIcons = [];\n    const providers = typeof provider === \"string\" ? [\n        provider\n    ] : Object.keys(dataStorage);\n    providers.forEach((provider2)=>{\n        const prefixes = typeof provider2 === \"string\" && typeof prefix === \"string\" ? [\n            prefix\n        ] : Object.keys(dataStorage[provider2] || {});\n        prefixes.forEach((prefix2)=>{\n            const storage = getStorage(provider2, prefix2);\n            allIcons = allIcons.concat(Object.keys(storage.icons).map((name)=>(provider2 !== \"\" ? \"@\" + provider2 + \":\" : \"\") + prefix2 + \":\" + name));\n        });\n    });\n    return allIcons;\n}\nlet simpleNames = false;\nfunction allowSimpleNames(allow) {\n    if (typeof allow === \"boolean\") {\n        simpleNames = allow;\n    }\n    return simpleNames;\n}\nfunction getIconData(name) {\n    const icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n    if (icon) {\n        const storage = getStorage(icon.provider, icon.prefix);\n        const iconName = icon.name;\n        return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n    }\n}\nfunction addIcon(name, data) {\n    const icon = stringToIcon(name, true, simpleNames);\n    if (!icon) {\n        return false;\n    }\n    const storage = getStorage(icon.provider, icon.prefix);\n    if (data) {\n        return addIconToStorage(storage, icon.name, data);\n    } else {\n        storage.missing.add(icon.name);\n        return true;\n    }\n}\nfunction addCollection(data, provider) {\n    if (typeof data !== \"object\") {\n        return false;\n    }\n    if (typeof provider !== \"string\") {\n        provider = data.provider || \"\";\n    }\n    if (simpleNames && !provider && !data.prefix) {\n        let added = false;\n        if (quicklyValidateIconSet(data)) {\n            data.prefix = \"\";\n            parseIconSet(data, (name, icon)=>{\n                if (addIcon(name, icon)) {\n                    added = true;\n                }\n            });\n        }\n        return added;\n    }\n    const prefix = data.prefix;\n    if (!validateIconName({\n        prefix,\n        name: \"a\"\n    })) {\n        return false;\n    }\n    const storage = getStorage(provider, prefix);\n    return !!addIconSet(storage, data);\n}\nfunction iconLoaded(name) {\n    return !!getIconData(name);\n}\nfunction getIcon(name) {\n    const result = getIconData(name);\n    return result ? {\n        ...defaultIconProps,\n        ...result\n    } : result;\n}\nconst defaultIconSizeCustomisations = Object.freeze({\n    width: null,\n    height: null\n});\nconst defaultIconCustomisations = Object.freeze({\n    // Dimensions\n    ...defaultIconSizeCustomisations,\n    // Transformations\n    ...defaultIconTransformations\n});\nconst unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n    if (ratio === 1) {\n        return size;\n    }\n    precision = precision || 100;\n    if (typeof size === \"number\") {\n        return Math.ceil(size * ratio * precision) / precision;\n    }\n    if (typeof size !== \"string\") {\n        return size;\n    }\n    const oldParts = size.split(unitsSplit);\n    if (oldParts === null || !oldParts.length) {\n        return size;\n    }\n    const newParts = [];\n    let code = oldParts.shift();\n    let isNumber = unitsTest.test(code);\n    while(true){\n        if (isNumber) {\n            const num = parseFloat(code);\n            if (isNaN(num)) {\n                newParts.push(code);\n            } else {\n                newParts.push(Math.ceil(num * ratio * precision) / precision);\n            }\n        } else {\n            newParts.push(code);\n        }\n        code = oldParts.shift();\n        if (code === void 0) {\n            return newParts.join(\"\");\n        }\n        isNumber = !isNumber;\n    }\n}\nfunction splitSVGDefs(content, tag = \"defs\") {\n    let defs = \"\";\n    const index = content.indexOf(\"<\" + tag);\n    while(index >= 0){\n        const start = content.indexOf(\">\", index);\n        const end = content.indexOf(\"</\" + tag);\n        if (start === -1 || end === -1) {\n            break;\n        }\n        const endEnd = content.indexOf(\">\", end);\n        if (endEnd === -1) {\n            break;\n        }\n        defs += content.slice(start + 1, end).trim();\n        content = content.slice(0, index).trim() + content.slice(endEnd + 1);\n    }\n    return {\n        defs,\n        content\n    };\n}\nfunction mergeDefsAndContent(defs, content) {\n    return defs ? \"<defs>\" + defs + \"</defs>\" + content : content;\n}\nfunction wrapSVGContent(body, start, end) {\n    const split = splitSVGDefs(body);\n    return mergeDefsAndContent(split.defs, start + split.content + end);\n}\nconst isUnsetKeyword = (value)=>value === \"unset\" || value === \"undefined\" || value === \"none\";\nfunction iconToSVG(icon, customisations) {\n    const fullIcon = {\n        ...defaultIconProps,\n        ...icon\n    };\n    const fullCustomisations = {\n        ...defaultIconCustomisations,\n        ...customisations\n    };\n    const box = {\n        left: fullIcon.left,\n        top: fullIcon.top,\n        width: fullIcon.width,\n        height: fullIcon.height\n    };\n    let body = fullIcon.body;\n    [\n        fullIcon,\n        fullCustomisations\n    ].forEach((props)=>{\n        const transformations = [];\n        const hFlip = props.hFlip;\n        const vFlip = props.vFlip;\n        let rotation = props.rotate;\n        if (hFlip) {\n            if (vFlip) {\n                rotation += 2;\n            } else {\n                transformations.push(\"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\");\n                transformations.push(\"scale(-1 1)\");\n                box.top = box.left = 0;\n            }\n        } else if (vFlip) {\n            transformations.push(\"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\");\n            transformations.push(\"scale(1 -1)\");\n            box.top = box.left = 0;\n        }\n        let tempValue;\n        if (rotation < 0) {\n            rotation -= Math.floor(rotation / 4) * 4;\n        }\n        rotation = rotation % 4;\n        switch(rotation){\n            case 1:\n                tempValue = box.height / 2 + box.top;\n                transformations.unshift(\"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n            case 2:\n                transformations.unshift(\"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\");\n                break;\n            case 3:\n                tempValue = box.width / 2 + box.left;\n                transformations.unshift(\"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n        }\n        if (rotation % 2 === 1) {\n            if (box.left !== box.top) {\n                tempValue = box.left;\n                box.left = box.top;\n                box.top = tempValue;\n            }\n            if (box.width !== box.height) {\n                tempValue = box.width;\n                box.width = box.height;\n                box.height = tempValue;\n            }\n        }\n        if (transformations.length) {\n            body = wrapSVGContent(body, '<g transform=\"' + transformations.join(\" \") + '\">', \"</g>\");\n        }\n    });\n    const customisationsWidth = fullCustomisations.width;\n    const customisationsHeight = fullCustomisations.height;\n    const boxWidth = box.width;\n    const boxHeight = box.height;\n    let width;\n    let height;\n    if (customisationsWidth === null) {\n        height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n        width = calculateSize(height, boxWidth / boxHeight);\n    } else {\n        width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n        height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    }\n    const attributes = {};\n    const setAttr = (prop, value)=>{\n        if (!isUnsetKeyword(value)) {\n            attributes[prop] = value.toString();\n        }\n    };\n    setAttr(\"width\", width);\n    setAttr(\"height\", height);\n    const viewBox = [\n        box.left,\n        box.top,\n        boxWidth,\n        boxHeight\n    ];\n    attributes.viewBox = viewBox.join(\" \");\n    return {\n        attributes,\n        viewBox,\n        body\n    };\n}\nconst regex = /\\sid=\"(\\S+)\"/g;\nconst randomPrefix = \"IconifyId\" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\nlet counter = 0;\nfunction replaceIDs(body, prefix = randomPrefix) {\n    const ids = [];\n    let match;\n    while(match = regex.exec(body)){\n        ids.push(match[1]);\n    }\n    if (!ids.length) {\n        return body;\n    }\n    const suffix = \"suffix\" + (Math.random() * 16777216 | Date.now()).toString(16);\n    ids.forEach((id)=>{\n        const newID = typeof prefix === \"function\" ? prefix(id) : prefix + (counter++).toString();\n        const escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n        body = body.replace(// Allowed characters before id: [#;\"]\n        // Allowed characters after id: [)\"], .[a-z]\n        new RegExp('([#;\"])(' + escapedID + ')([\")]|\\\\.[a-z])', \"g\"), \"$1\" + newID + suffix + \"$3\");\n    });\n    body = body.replace(new RegExp(suffix, \"g\"), \"\");\n    return body;\n}\nconst storage = /* @__PURE__ */ Object.create(null);\nfunction setAPIModule(provider, item) {\n    storage[provider] = item;\n}\nfunction getAPIModule(provider) {\n    return storage[provider] || storage[\"\"];\n}\nfunction createAPIConfig(source) {\n    let resources;\n    if (typeof source.resources === \"string\") {\n        resources = [\n            source.resources\n        ];\n    } else {\n        resources = source.resources;\n        if (!(resources instanceof Array) || !resources.length) {\n            return null;\n        }\n    }\n    const result = {\n        // API hosts\n        resources,\n        // Root path\n        path: source.path || \"/\",\n        // URL length limit\n        maxURL: source.maxURL || 500,\n        // Timeout before next host is used.\n        rotate: source.rotate || 750,\n        // Timeout before failing query.\n        timeout: source.timeout || 5e3,\n        // Randomise default API end point.\n        random: source.random === true,\n        // Start index\n        index: source.index || 0,\n        // Receive data after time out (used if time out kicks in first, then API module sends data anyway).\n        dataAfterTimeout: source.dataAfterTimeout !== false\n    };\n    return result;\n}\nconst configStorage = /* @__PURE__ */ Object.create(null);\nconst fallBackAPISources = [\n    \"https://api.simplesvg.com\",\n    \"https://api.unisvg.com\"\n];\nconst fallBackAPI = [];\nwhile(fallBackAPISources.length > 0){\n    if (fallBackAPISources.length === 1) {\n        fallBackAPI.push(fallBackAPISources.shift());\n    } else {\n        if (Math.random() > 0.5) {\n            fallBackAPI.push(fallBackAPISources.shift());\n        } else {\n            fallBackAPI.push(fallBackAPISources.pop());\n        }\n    }\n}\nconfigStorage[\"\"] = createAPIConfig({\n    resources: [\n        \"https://api.iconify.design\"\n    ].concat(fallBackAPI)\n});\nfunction addAPIProvider(provider, customConfig) {\n    const config = createAPIConfig(customConfig);\n    if (config === null) {\n        return false;\n    }\n    configStorage[provider] = config;\n    return true;\n}\nfunction getAPIConfig(provider) {\n    return configStorage[provider];\n}\nfunction listAPIProviders() {\n    return Object.keys(configStorage);\n}\nconst detectFetch = ()=>{\n    let callback;\n    try {\n        callback = fetch;\n        if (typeof callback === \"function\") {\n            return callback;\n        }\n    } catch (err) {}\n};\nlet fetchModule = detectFetch();\nfunction setFetch(fetch2) {\n    fetchModule = fetch2;\n}\nfunction getFetch() {\n    return fetchModule;\n}\nfunction calculateMaxLength(provider, prefix) {\n    const config = getAPIConfig(provider);\n    if (!config) {\n        return 0;\n    }\n    let result;\n    if (!config.maxURL) {\n        result = 0;\n    } else {\n        let maxHostLength = 0;\n        config.resources.forEach((item)=>{\n            const host = item;\n            maxHostLength = Math.max(maxHostLength, host.length);\n        });\n        const url = prefix + \".json?icons=\";\n        result = config.maxURL - maxHostLength - config.path.length - url.length;\n    }\n    return result;\n}\nfunction shouldAbort(status) {\n    return status === 404;\n}\nconst prepare = (provider, prefix, icons)=>{\n    const results = [];\n    const maxLength = calculateMaxLength(provider, prefix);\n    const type = \"icons\";\n    let item = {\n        type,\n        provider,\n        prefix,\n        icons: []\n    };\n    let length = 0;\n    icons.forEach((name, index)=>{\n        length += name.length + 1;\n        if (length >= maxLength && index > 0) {\n            results.push(item);\n            item = {\n                type,\n                provider,\n                prefix,\n                icons: []\n            };\n            length = name.length;\n        }\n        item.icons.push(name);\n    });\n    results.push(item);\n    return results;\n};\nfunction getPath(provider) {\n    if (typeof provider === \"string\") {\n        const config = getAPIConfig(provider);\n        if (config) {\n            return config.path;\n        }\n    }\n    return \"/\";\n}\nconst send = (host, params, callback)=>{\n    if (!fetchModule) {\n        callback(\"abort\", 424);\n        return;\n    }\n    let path = getPath(params.provider);\n    switch(params.type){\n        case \"icons\":\n            {\n                const prefix = params.prefix;\n                const icons = params.icons;\n                const iconsList = icons.join(\",\");\n                const urlParams = new URLSearchParams({\n                    icons: iconsList\n                });\n                path += prefix + \".json?\" + urlParams.toString();\n                break;\n            }\n        case \"custom\":\n            {\n                const uri = params.uri;\n                path += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n                break;\n            }\n        default:\n            callback(\"abort\", 400);\n            return;\n    }\n    let defaultError = 503;\n    fetchModule(host + path).then((response)=>{\n        const status = response.status;\n        if (status !== 200) {\n            setTimeout(()=>{\n                callback(shouldAbort(status) ? \"abort\" : \"next\", status);\n            });\n            return;\n        }\n        defaultError = 501;\n        return response.json();\n    }).then((data)=>{\n        if (typeof data !== \"object\" || data === null) {\n            setTimeout(()=>{\n                if (data === 404) {\n                    callback(\"abort\", data);\n                } else {\n                    callback(\"next\", defaultError);\n                }\n            });\n            return;\n        }\n        setTimeout(()=>{\n            callback(\"success\", data);\n        });\n    }).catch(()=>{\n        callback(\"next\", defaultError);\n    });\n};\nconst fetchAPIModule = {\n    prepare,\n    send\n};\nfunction sortIcons(icons) {\n    const result = {\n        loaded: [],\n        missing: [],\n        pending: []\n    };\n    const storage = /* @__PURE__ */ Object.create(null);\n    icons.sort((a, b)=>{\n        if (a.provider !== b.provider) {\n            return a.provider.localeCompare(b.provider);\n        }\n        if (a.prefix !== b.prefix) {\n            return a.prefix.localeCompare(b.prefix);\n        }\n        return a.name.localeCompare(b.name);\n    });\n    let lastIcon = {\n        provider: \"\",\n        prefix: \"\",\n        name: \"\"\n    };\n    icons.forEach((icon)=>{\n        if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {\n            return;\n        }\n        lastIcon = icon;\n        const provider = icon.provider;\n        const prefix = icon.prefix;\n        const name = icon.name;\n        const providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));\n        const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n        let list;\n        if (name in localStorage.icons) {\n            list = result.loaded;\n        } else if (prefix === \"\" || localStorage.missing.has(name)) {\n            list = result.missing;\n        } else {\n            list = result.pending;\n        }\n        const item = {\n            provider,\n            prefix,\n            name\n        };\n        list.push(item);\n    });\n    return result;\n}\nfunction removeCallback(storages, id) {\n    storages.forEach((storage)=>{\n        const items = storage.loaderCallbacks;\n        if (items) {\n            storage.loaderCallbacks = items.filter((row)=>row.id !== id);\n        }\n    });\n}\nfunction updateCallbacks(storage) {\n    if (!storage.pendingCallbacksFlag) {\n        storage.pendingCallbacksFlag = true;\n        setTimeout(()=>{\n            storage.pendingCallbacksFlag = false;\n            const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n            if (!items.length) {\n                return;\n            }\n            let hasPending = false;\n            const provider = storage.provider;\n            const prefix = storage.prefix;\n            items.forEach((item)=>{\n                const icons = item.icons;\n                const oldLength = icons.pending.length;\n                icons.pending = icons.pending.filter((icon)=>{\n                    if (icon.prefix !== prefix) {\n                        return true;\n                    }\n                    const name = icon.name;\n                    if (storage.icons[name]) {\n                        icons.loaded.push({\n                            provider,\n                            prefix,\n                            name\n                        });\n                    } else if (storage.missing.has(name)) {\n                        icons.missing.push({\n                            provider,\n                            prefix,\n                            name\n                        });\n                    } else {\n                        hasPending = true;\n                        return true;\n                    }\n                    return false;\n                });\n                if (icons.pending.length !== oldLength) {\n                    if (!hasPending) {\n                        removeCallback([\n                            storage\n                        ], item.id);\n                    }\n                    item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);\n                }\n            });\n        });\n    }\n}\nlet idCounter = 0;\nfunction storeCallback(callback, icons, pendingSources) {\n    const id = idCounter++;\n    const abort = removeCallback.bind(null, pendingSources, id);\n    if (!icons.pending.length) {\n        return abort;\n    }\n    const item = {\n        id,\n        icons,\n        callback,\n        abort\n    };\n    pendingSources.forEach((storage)=>{\n        (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n    });\n    return abort;\n}\nfunction listToIcons(list, validate = true, simpleNames = false) {\n    const result = [];\n    list.forEach((item)=>{\n        const icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n        if (icon) {\n            result.push(icon);\n        }\n    });\n    return result;\n}\n// src/config.ts\nvar defaultConfig = {\n    resources: [],\n    index: 0,\n    timeout: 2e3,\n    rotate: 750,\n    random: false,\n    dataAfterTimeout: false\n};\n// src/query.ts\nfunction sendQuery(config, payload, query, done) {\n    const resourcesCount = config.resources.length;\n    const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n    let resources;\n    if (config.random) {\n        let list = config.resources.slice(0);\n        resources = [];\n        while(list.length > 1){\n            const nextIndex = Math.floor(Math.random() * list.length);\n            resources.push(list[nextIndex]);\n            list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n        }\n        resources = resources.concat(list);\n    } else {\n        resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n    }\n    const startTime = Date.now();\n    let status = \"pending\";\n    let queriesSent = 0;\n    let lastError;\n    let timer = null;\n    let queue = [];\n    let doneCallbacks = [];\n    if (typeof done === \"function\") {\n        doneCallbacks.push(done);\n    }\n    function resetTimer() {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n    }\n    function abort() {\n        if (status === \"pending\") {\n            status = \"aborted\";\n        }\n        resetTimer();\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function subscribe(callback, overwrite) {\n        if (overwrite) {\n            doneCallbacks = [];\n        }\n        if (typeof callback === \"function\") {\n            doneCallbacks.push(callback);\n        }\n    }\n    function getQueryStatus() {\n        return {\n            startTime,\n            payload,\n            status,\n            queriesSent,\n            queriesPending: queue.length,\n            subscribe,\n            abort\n        };\n    }\n    function failQuery() {\n        status = \"failed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(void 0, lastError);\n        });\n    }\n    function clearQueue() {\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function moduleResponse(item, response, data) {\n        const isError = response !== \"success\";\n        queue = queue.filter((queued)=>queued !== item);\n        switch(status){\n            case \"pending\":\n                break;\n            case \"failed\":\n                if (isError || !config.dataAfterTimeout) {\n                    return;\n                }\n                break;\n            default:\n                return;\n        }\n        if (response === \"abort\") {\n            lastError = data;\n            failQuery();\n            return;\n        }\n        if (isError) {\n            lastError = data;\n            if (!queue.length) {\n                if (!resources.length) {\n                    failQuery();\n                } else {\n                    execNext();\n                }\n            }\n            return;\n        }\n        resetTimer();\n        clearQueue();\n        if (!config.random) {\n            const index = config.resources.indexOf(item.resource);\n            if (index !== -1 && index !== config.index) {\n                config.index = index;\n            }\n        }\n        status = \"completed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(data);\n        });\n    }\n    function execNext() {\n        if (status !== \"pending\") {\n            return;\n        }\n        resetTimer();\n        const resource = resources.shift();\n        if (resource === void 0) {\n            if (queue.length) {\n                timer = setTimeout(()=>{\n                    resetTimer();\n                    if (status === \"pending\") {\n                        clearQueue();\n                        failQuery();\n                    }\n                }, config.timeout);\n                return;\n            }\n            failQuery();\n            return;\n        }\n        const item = {\n            status: \"pending\",\n            resource,\n            callback: (status2, data)=>{\n                moduleResponse(item, status2, data);\n            }\n        };\n        queue.push(item);\n        queriesSent++;\n        timer = setTimeout(execNext, config.rotate);\n        query(resource, payload, item.callback);\n    }\n    setTimeout(execNext);\n    return getQueryStatus;\n}\n// src/index.ts\nfunction initRedundancy(cfg) {\n    const config = {\n        ...defaultConfig,\n        ...cfg\n    };\n    let queries = [];\n    function cleanup() {\n        queries = queries.filter((item)=>item().status === \"pending\");\n    }\n    function query(payload, queryCallback, doneCallback) {\n        const query2 = sendQuery(config, payload, queryCallback, (data, error)=>{\n            cleanup();\n            if (doneCallback) {\n                doneCallback(data, error);\n            }\n        });\n        queries.push(query2);\n        return query2;\n    }\n    function find(callback) {\n        return queries.find((value)=>{\n            return callback(value);\n        }) || null;\n    }\n    const instance = {\n        query,\n        find,\n        setIndex: (index)=>{\n            config.index = index;\n        },\n        getIndex: ()=>config.index,\n        cleanup\n    };\n    return instance;\n}\nfunction emptyCallback$1() {}\nconst redundancyCache = /* @__PURE__ */ Object.create(null);\nfunction getRedundancyCache(provider) {\n    if (!redundancyCache[provider]) {\n        const config = getAPIConfig(provider);\n        if (!config) {\n            return;\n        }\n        const redundancy = initRedundancy(config);\n        const cachedReundancy = {\n            config,\n            redundancy\n        };\n        redundancyCache[provider] = cachedReundancy;\n    }\n    return redundancyCache[provider];\n}\nfunction sendAPIQuery(target, query, callback) {\n    let redundancy;\n    let send;\n    if (typeof target === \"string\") {\n        const api = getAPIModule(target);\n        if (!api) {\n            callback(void 0, 424);\n            return emptyCallback$1;\n        }\n        send = api.send;\n        const cached = getRedundancyCache(target);\n        if (cached) {\n            redundancy = cached.redundancy;\n        }\n    } else {\n        const config = createAPIConfig(target);\n        if (config) {\n            redundancy = initRedundancy(config);\n            const moduleKey = target.resources ? target.resources[0] : \"\";\n            const api = getAPIModule(moduleKey);\n            if (api) {\n                send = api.send;\n            }\n        }\n    }\n    if (!redundancy || !send) {\n        callback(void 0, 424);\n        return emptyCallback$1;\n    }\n    return redundancy.query(query, send, callback)().abort;\n}\nfunction emptyCallback() {}\nfunction loadedNewIcons(storage) {\n    if (!storage.iconsLoaderFlag) {\n        storage.iconsLoaderFlag = true;\n        setTimeout(()=>{\n            storage.iconsLoaderFlag = false;\n            updateCallbacks(storage);\n        });\n    }\n}\nfunction checkIconNamesForAPI(icons) {\n    const valid = [];\n    const invalid = [];\n    icons.forEach((name)=>{\n        (name.match(matchIconName) ? valid : invalid).push(name);\n    });\n    return {\n        valid,\n        invalid\n    };\n}\nfunction parseLoaderResponse(storage, icons, data) {\n    function checkMissing() {\n        const pending = storage.pendingIcons;\n        icons.forEach((name)=>{\n            if (pending) {\n                pending.delete(name);\n            }\n            if (!storage.icons[name]) {\n                storage.missing.add(name);\n            }\n        });\n    }\n    if (data && typeof data === \"object\") {\n        try {\n            const parsed = addIconSet(storage, data);\n            if (!parsed.length) {\n                checkMissing();\n                return;\n            }\n        } catch (err) {\n            console.error(err);\n        }\n    }\n    checkMissing();\n    loadedNewIcons(storage);\n}\nfunction parsePossiblyAsyncResponse(response, callback) {\n    if (response instanceof Promise) {\n        response.then((data)=>{\n            callback(data);\n        }).catch(()=>{\n            callback(null);\n        });\n    } else {\n        callback(response);\n    }\n}\nfunction loadNewIcons(storage, icons) {\n    if (!storage.iconsToLoad) {\n        storage.iconsToLoad = icons;\n    } else {\n        storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n    }\n    if (!storage.iconsQueueFlag) {\n        storage.iconsQueueFlag = true;\n        setTimeout(()=>{\n            storage.iconsQueueFlag = false;\n            const { provider, prefix } = storage;\n            const icons2 = storage.iconsToLoad;\n            delete storage.iconsToLoad;\n            if (!icons2 || !icons2.length) {\n                return;\n            }\n            const customIconLoader = storage.loadIcon;\n            if (storage.loadIcons && (icons2.length > 1 || !customIconLoader)) {\n                parsePossiblyAsyncResponse(storage.loadIcons(icons2, prefix, provider), (data)=>{\n                    parseLoaderResponse(storage, icons2, data);\n                });\n                return;\n            }\n            if (customIconLoader) {\n                icons2.forEach((name)=>{\n                    const response = customIconLoader(name, prefix, provider);\n                    parsePossiblyAsyncResponse(response, (data)=>{\n                        const iconSet = data ? {\n                            prefix,\n                            icons: {\n                                [name]: data\n                            }\n                        } : null;\n                        parseLoaderResponse(storage, [\n                            name\n                        ], iconSet);\n                    });\n                });\n                return;\n            }\n            const { valid, invalid } = checkIconNamesForAPI(icons2);\n            if (invalid.length) {\n                parseLoaderResponse(storage, invalid, null);\n            }\n            if (!valid.length) {\n                return;\n            }\n            const api = prefix.match(matchIconName) ? getAPIModule(provider) : null;\n            if (!api) {\n                parseLoaderResponse(storage, valid, null);\n                return;\n            }\n            const params = api.prepare(provider, prefix, valid);\n            params.forEach((item)=>{\n                sendAPIQuery(provider, item, (data)=>{\n                    parseLoaderResponse(storage, item.icons, data);\n                });\n            });\n        });\n    }\n}\nconst loadIcons = (icons, callback)=>{\n    const cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n    const sortedIcons = sortIcons(cleanedIcons);\n    if (!sortedIcons.pending.length) {\n        let callCallback = true;\n        if (callback) {\n            setTimeout(()=>{\n                if (callCallback) {\n                    callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);\n                }\n            });\n        }\n        return ()=>{\n            callCallback = false;\n        };\n    }\n    const newIcons = /* @__PURE__ */ Object.create(null);\n    const sources = [];\n    let lastProvider, lastPrefix;\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix } = icon;\n        if (prefix === lastPrefix && provider === lastProvider) {\n            return;\n        }\n        lastProvider = provider;\n        lastPrefix = prefix;\n        sources.push(getStorage(provider, prefix));\n        const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));\n        if (!providerNewIcons[prefix]) {\n            providerNewIcons[prefix] = [];\n        }\n    });\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix, name } = icon;\n        const storage = getStorage(provider, prefix);\n        const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n        if (!pendingQueue.has(name)) {\n            pendingQueue.add(name);\n            newIcons[provider][prefix].push(name);\n        }\n    });\n    sources.forEach((storage)=>{\n        const list = newIcons[storage.provider][storage.prefix];\n        if (list.length) {\n            loadNewIcons(storage, list);\n        }\n    });\n    return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\nconst loadIcon = (icon)=>{\n    return new Promise((fulfill, reject)=>{\n        const iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n        if (!iconObj) {\n            reject(icon);\n            return;\n        }\n        loadIcons([\n            iconObj || icon\n        ], (loaded)=>{\n            if (loaded.length && iconObj) {\n                const data = getIconData(iconObj);\n                if (data) {\n                    fulfill({\n                        ...defaultIconProps,\n                        ...data\n                    });\n                    return;\n                }\n            }\n            reject(icon);\n        });\n    });\n};\nfunction setCustomIconsLoader(loader, prefix, provider) {\n    getStorage(provider || \"\", prefix).loadIcons = loader;\n}\nfunction setCustomIconLoader(loader, prefix, provider) {\n    getStorage(provider || \"\", prefix).loadIcon = loader;\n}\nfunction mergeCustomisations(defaults, item) {\n    const result = {\n        ...defaults\n    };\n    for(const key in item){\n        const value = item[key];\n        const valueType = typeof value;\n        if (key in defaultIconSizeCustomisations) {\n            if (value === null || value && (valueType === \"string\" || valueType === \"number\")) {\n                result[key] = value;\n            }\n        } else if (valueType === typeof result[key]) {\n            result[key] = key === \"rotate\" ? value % 4 : value;\n        }\n    }\n    return result;\n}\nconst separator = /[\\s,]+/;\nfunction flipFromString(custom, flip) {\n    flip.split(separator).forEach((str)=>{\n        const value = str.trim();\n        switch(value){\n            case \"horizontal\":\n                custom.hFlip = true;\n                break;\n            case \"vertical\":\n                custom.vFlip = true;\n                break;\n        }\n    });\n}\nfunction rotateFromString(value, defaultValue = 0) {\n    const units = value.replace(/^-?[0-9.]*/, \"\");\n    function cleanup(value2) {\n        while(value2 < 0){\n            value2 += 4;\n        }\n        return value2 % 4;\n    }\n    if (units === \"\") {\n        const num = parseInt(value);\n        return isNaN(num) ? 0 : cleanup(num);\n    } else if (units !== value) {\n        let split = 0;\n        switch(units){\n            case \"%\":\n                split = 25;\n                break;\n            case \"deg\":\n                split = 90;\n        }\n        if (split) {\n            let num = parseFloat(value.slice(0, value.length - units.length));\n            if (isNaN(num)) {\n                return 0;\n            }\n            num = num / split;\n            return num % 1 === 0 ? cleanup(num) : 0;\n        }\n    }\n    return defaultValue;\n}\nfunction iconToHTML(body, attributes) {\n    let renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n    for(const attr in attributes){\n        renderAttribsHTML += \" \" + attr + '=\"' + attributes[attr] + '\"';\n    }\n    return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\nfunction encodeSVGforURL(svg) {\n    return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\nfunction svgToData(svg) {\n    return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\nfunction svgToURL(svg) {\n    return 'url(\"' + svgToData(svg) + '\")';\n}\nlet policy;\nfunction createPolicy() {\n    try {\n        policy = window.trustedTypes.createPolicy(\"iconify\", {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            createHTML: (s)=>s\n        });\n    } catch (err) {\n        policy = null;\n    }\n}\nfunction cleanUpInnerHTML(html) {\n    if (policy === void 0) {\n        createPolicy();\n    }\n    return policy ? policy.createHTML(html) : html;\n}\nconst defaultExtendedIconCustomisations = {\n    ...defaultIconCustomisations,\n    inline: false\n};\n/**\n * Default SVG attributes\n */ const svgDefaults = {\n    'xmlns': 'http://www.w3.org/2000/svg',\n    'xmlnsXlink': 'http://www.w3.org/1999/xlink',\n    'aria-hidden': true,\n    'role': 'img'\n};\n/**\n * Style modes\n */ const commonProps = {\n    display: 'inline-block'\n};\nconst monotoneProps = {\n    backgroundColor: 'currentColor'\n};\nconst coloredProps = {\n    backgroundColor: 'transparent'\n};\n// Dynamically add common props to variables above\nconst propsToAdd = {\n    Image: 'var(--svg)',\n    Repeat: 'no-repeat',\n    Size: '100% 100%'\n};\nconst propsToAddTo = {\n    WebkitMask: monotoneProps,\n    mask: monotoneProps,\n    background: coloredProps\n};\nfor(const prefix in propsToAddTo){\n    const list = propsToAddTo[prefix];\n    for(const prop in propsToAdd){\n        list[prefix + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Default values for customisations for inline icon\n */ const inlineDefaults = {\n    ...defaultExtendedIconCustomisations,\n    inline: true\n};\n/**\n * Fix size: add 'px' to numbers\n */ function fixSize(value) {\n    return value + (value.match(/^[-0-9.]+$/) ? 'px' : '');\n}\n/**\n * Render icon\n */ const render = (// Icon must be validated before calling this function\nicon, // Partial properties\nprops, // Icon name\nname)=>{\n    // Get default properties\n    const defaultProps = props.inline ? inlineDefaults : defaultExtendedIconCustomisations;\n    // Get all customisations\n    const customisations = mergeCustomisations(defaultProps, props);\n    // Check mode\n    const mode = props.mode || 'svg';\n    // Create style\n    const style = {};\n    const customStyle = props.style || {};\n    // Create SVG component properties\n    const componentProps = {\n        ...mode === 'svg' ? svgDefaults : {}\n    };\n    if (name) {\n        const iconName = stringToIcon(name, false, true);\n        if (iconName) {\n            const classNames = [\n                'iconify'\n            ];\n            const props = [\n                'provider',\n                'prefix'\n            ];\n            for (const prop of props){\n                if (iconName[prop]) {\n                    classNames.push('iconify--' + iconName[prop]);\n                }\n            }\n            componentProps.className = classNames.join(' ');\n        }\n    }\n    // Get element properties\n    for(let key in props){\n        const value = props[key];\n        if (value === void 0) {\n            continue;\n        }\n        switch(key){\n            // Properties to ignore\n            case 'icon':\n            case 'style':\n            case 'children':\n            case 'onLoad':\n            case 'mode':\n            case 'ssr':\n                break;\n            // Forward ref\n            case '_ref':\n                componentProps.ref = value;\n                break;\n            // Merge class names\n            case 'className':\n                componentProps[key] = (componentProps[key] ? componentProps[key] + ' ' : '') + value;\n                break;\n            // Boolean attributes\n            case 'inline':\n            case 'hFlip':\n            case 'vFlip':\n                customisations[key] = value === true || value === 'true' || value === 1;\n                break;\n            // Flip as string: 'horizontal,vertical'\n            case 'flip':\n                if (typeof value === 'string') {\n                    flipFromString(customisations, value);\n                }\n                break;\n            // Color: copy to style\n            case 'color':\n                style.color = value;\n                break;\n            // Rotation as string\n            case 'rotate':\n                if (typeof value === 'string') {\n                    customisations[key] = rotateFromString(value);\n                } else if (typeof value === 'number') {\n                    customisations[key] = value;\n                }\n                break;\n            // Remove aria-hidden\n            case 'ariaHidden':\n            case 'aria-hidden':\n                if (value !== true && value !== 'true') {\n                    delete componentProps['aria-hidden'];\n                }\n                break;\n            // Copy missing property if it does not exist in customisations\n            default:\n                if (defaultProps[key] === void 0) {\n                    componentProps[key] = value;\n                }\n        }\n    }\n    // Generate icon\n    const item = iconToSVG(icon, customisations);\n    const renderAttribs = item.attributes;\n    // Inline display\n    if (customisations.inline) {\n        style.verticalAlign = '-0.125em';\n    }\n    if (mode === 'svg') {\n        // Add style\n        componentProps.style = {\n            ...style,\n            ...customStyle\n        };\n        // Add icon stuff\n        Object.assign(componentProps, renderAttribs);\n        // Counter for ids based on \"id\" property to render icons consistently on server and client\n        let localCounter = 0;\n        let id = props.id;\n        if (typeof id === 'string') {\n            // Convert '-' to '_' to avoid errors in animations\n            id = id.replace(/-/g, '_');\n        }\n        // Add icon stuff\n        componentProps.dangerouslySetInnerHTML = {\n            __html: cleanUpInnerHTML(replaceIDs(item.body, id ? ()=>id + 'ID' + localCounter++ : 'iconifyReact'))\n        };\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)('svg', componentProps);\n    }\n    // Render <span> with style\n    const { body, width, height } = icon;\n    const useMask = mode === 'mask' || (mode === 'bg' ? false : body.indexOf('currentColor') !== -1);\n    // Generate SVG\n    const html = iconToHTML(body, {\n        ...renderAttribs,\n        width: width + '',\n        height: height + ''\n    });\n    // Generate style\n    componentProps.style = {\n        ...style,\n        '--svg': svgToURL(html),\n        'width': fixSize(renderAttribs.width),\n        'height': fixSize(renderAttribs.height),\n        ...commonProps,\n        ...useMask ? monotoneProps : coloredProps,\n        ...customStyle\n    };\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)('span', componentProps);\n};\n/**\n * Initialise stuff\n */ // Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule('', fetchAPIModule);\n/**\n * Browser stuff\n */ if (typeof document !== 'undefined' && \"undefined\" !== 'undefined') {}\nfunction IconComponent(props) {\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!!props.ssr);\n    const [abort, setAbort] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    // Get initial state\n    function getInitialState(mounted) {\n        if (mounted) {\n            const name = props.icon;\n            if (typeof name === 'object') {\n                // Icon as object\n                return {\n                    name: '',\n                    data: name\n                };\n            }\n            const data = getIconData(name);\n            if (data) {\n                return {\n                    name,\n                    data\n                };\n            }\n        }\n        return {\n            name: ''\n        };\n    }\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getInitialState(!!props.ssr));\n    // Cancel loading\n    function cleanup() {\n        const callback = abort.callback;\n        if (callback) {\n            callback();\n            setAbort({});\n        }\n    }\n    // Change state if it is different\n    function changeState(newState) {\n        if (JSON.stringify(state) !== JSON.stringify(newState)) {\n            cleanup();\n            setState(newState);\n            return true;\n        }\n    }\n    // Update state\n    function updateState() {\n        var _a;\n        const name = props.icon;\n        if (typeof name === 'object') {\n            // Icon as object\n            changeState({\n                name: '',\n                data: name\n            });\n            return;\n        }\n        // New icon or got icon data\n        const data = getIconData(name);\n        if (changeState({\n            name,\n            data\n        })) {\n            if (data === undefined) {\n                // Load icon, update state when done\n                const callback = loadIcons([\n                    name\n                ], updateState);\n                setAbort({\n                    callback\n                });\n            } else if (data) {\n                // Icon data is available: trigger onLoad callback if present\n                (_a = props.onLoad) === null || _a === void 0 ? void 0 : _a.call(props, name);\n            }\n        }\n    }\n    // Mounted state, cleanup for loader\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"IconComponent.useEffect\": ()=>{\n            setMounted(true);\n            return cleanup;\n        }\n    }[\"IconComponent.useEffect\"], []);\n    // Icon changed or component mounted\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"IconComponent.useEffect\": ()=>{\n            if (mounted) {\n                updateState();\n            }\n        }\n    }[\"IconComponent.useEffect\"], [\n        props.icon,\n        mounted\n    ]);\n    // Render icon\n    const { name, data } = state;\n    if (!data) {\n        return props.children ? props.children : props.fallback ? props.fallback : /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)('span', {});\n    }\n    return render({\n        ...defaultIconProps,\n        ...data\n    }, props, name);\n}\n/**\n * Block icon\n *\n * @param props - Component properties\n */ const Icon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>IconComponent({\n        ...props,\n        _ref: ref\n    }));\n/**\n * Inline icon (has negative verticalAlign that makes it behave like icon font)\n *\n * @param props - Component properties\n */ const InlineIcon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>IconComponent({\n        inline: true,\n        ...props,\n        _ref: ref\n    }));\n/**\n * Internal API\n */ const _api = {\n    getAPIConfig,\n    setAPIModule,\n    sendAPIQuery,\n    setFetch,\n    getFetch,\n    listAPIProviders\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGljb25pZnkvcmVhY3QvZGlzdC9pY29uaWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJPQUV1RTtBQUV2RSxNQUFNSSx3QkFBd0JDLE9BQU9DLE1BQU0sQ0FDekM7SUFDRUMsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLE9BQU87SUFDUEMsUUFBUTtBQUNWO0FBRUYsTUFBTUMsNkJBQTZCTixPQUFPQyxNQUFNLENBQUM7SUFDL0NNLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFPO0FBQ1Q7QUFDQSxNQUFNQyxtQkFBbUJWLE9BQU9DLE1BQU0sQ0FBQztJQUNyQyxHQUFHRixxQkFBcUI7SUFDeEIsR0FBR08sMEJBQTBCO0FBQy9CO0FBQ0EsTUFBTUssMkJBQTJCWCxPQUFPQyxNQUFNLENBQUM7SUFDN0MsR0FBR1MsZ0JBQWdCO0lBQ25CRSxNQUFNO0lBQ05DLFFBQVE7QUFDVjtBQUVBLFNBQVNDLHlCQUF5QkMsSUFBSSxFQUFFQyxJQUFJO0lBQzFDLE1BQU1DLFNBQVMsQ0FBQztJQUNoQixJQUFJLENBQUNGLEtBQUtOLEtBQUssS0FBSyxDQUFDTyxLQUFLUCxLQUFLLEVBQUU7UUFDL0JRLE9BQU9SLEtBQUssR0FBRztJQUNqQjtJQUNBLElBQUksQ0FBQ00sS0FBS1AsS0FBSyxLQUFLLENBQUNRLEtBQUtSLEtBQUssRUFBRTtRQUMvQlMsT0FBT1QsS0FBSyxHQUFHO0lBQ2pCO0lBQ0EsTUFBTUQsU0FBUyxDQUFDLENBQUNRLEtBQUtSLE1BQU0sSUFBSSxLQUFNUyxDQUFBQSxLQUFLVCxNQUFNLElBQUksRUFBQyxJQUFLO0lBQzNELElBQUlBLFFBQVE7UUFDVlUsT0FBT1YsTUFBTSxHQUFHQTtJQUNsQjtJQUNBLE9BQU9VO0FBQ1Q7QUFFQSxTQUFTQyxjQUFjQyxNQUFNLEVBQUVDLEtBQUs7SUFDbEMsTUFBTUgsU0FBU0gseUJBQXlCSyxRQUFRQztJQUNoRCxJQUFLLE1BQU1DLE9BQU9WLHlCQUEwQjtRQUMxQyxJQUFJVSxPQUFPZiw0QkFBNEI7WUFDckMsSUFBSWUsT0FBT0YsVUFBVSxDQUFFRSxDQUFBQSxPQUFPSixNQUFLLEdBQUk7Z0JBQ3JDQSxNQUFNLENBQUNJLElBQUksR0FBR2YsMEJBQTBCLENBQUNlLElBQUk7WUFDL0M7UUFDRixPQUFPLElBQUlBLE9BQU9ELE9BQU87WUFDdkJILE1BQU0sQ0FBQ0ksSUFBSSxHQUFHRCxLQUFLLENBQUNDLElBQUk7UUFDMUIsT0FBTyxJQUFJQSxPQUFPRixRQUFRO1lBQ3hCRixNQUFNLENBQUNJLElBQUksR0FBR0YsTUFBTSxDQUFDRSxJQUFJO1FBQzNCO0lBQ0Y7SUFDQSxPQUFPSjtBQUNUO0FBRUEsU0FBU0ssYUFBYUMsSUFBSSxFQUFFQyxLQUFLO0lBQy9CLE1BQU1DLFFBQVFGLEtBQUtFLEtBQUs7SUFDeEIsTUFBTUMsVUFBVUgsS0FBS0csT0FBTyxJQUFJLGFBQWEsR0FBRzFCLE9BQU8yQixNQUFNLENBQUM7SUFDOUQsTUFBTUMsV0FBVyxhQUFhLEdBQUc1QixPQUFPMkIsTUFBTSxDQUFDO0lBQy9DLFNBQVNFLFFBQVFDLElBQUk7UUFDbkIsSUFBSUwsS0FBSyxDQUFDSyxLQUFLLEVBQUU7WUFDZixPQUFPRixRQUFRLENBQUNFLEtBQUssR0FBRyxFQUFFO1FBQzVCO1FBQ0EsSUFBSSxDQUFFQSxDQUFBQSxRQUFRRixRQUFPLEdBQUk7WUFDdkJBLFFBQVEsQ0FBQ0UsS0FBSyxHQUFHO1lBQ2pCLE1BQU1YLFNBQVNPLE9BQU8sQ0FBQ0ksS0FBSyxJQUFJSixPQUFPLENBQUNJLEtBQUssQ0FBQ1gsTUFBTTtZQUNwRCxNQUFNWSxRQUFRWixVQUFVVSxRQUFRVjtZQUNoQyxJQUFJWSxPQUFPO2dCQUNUSCxRQUFRLENBQUNFLEtBQUssR0FBRztvQkFBQ1g7aUJBQU8sQ0FBQ2EsTUFBTSxDQUFDRDtZQUNuQztRQUNGO1FBQ0EsT0FBT0gsUUFBUSxDQUFDRSxLQUFLO0lBQ3ZCO0lBQ0M5QixPQUFPaUMsSUFBSSxDQUFDUixPQUFPTyxNQUFNLENBQUNoQyxPQUFPaUMsSUFBSSxDQUFDUCxVQUFXUSxPQUFPLENBQUNMO0lBQzFELE9BQU9EO0FBQ1Q7QUFFQSxTQUFTTyxvQkFBb0JaLElBQUksRUFBRU8sSUFBSSxFQUFFTSxJQUFJO0lBQzNDLE1BQU1YLFFBQVFGLEtBQUtFLEtBQUs7SUFDeEIsTUFBTUMsVUFBVUgsS0FBS0csT0FBTyxJQUFJLGFBQWEsR0FBRzFCLE9BQU8yQixNQUFNLENBQUM7SUFDOUQsSUFBSVUsZUFBZSxDQUFDO0lBQ3BCLFNBQVNDLE1BQU1DLEtBQUs7UUFDbEJGLGVBQWVuQixjQUNiTyxLQUFLLENBQUNjLE1BQU0sSUFBSWIsT0FBTyxDQUFDYSxNQUFNLEVBQzlCRjtJQUVKO0lBQ0FDLE1BQU1SO0lBQ05NLEtBQUtGLE9BQU8sQ0FBQ0k7SUFDYixPQUFPcEIsY0FBY0ssTUFBTWM7QUFDN0I7QUFFQSxTQUFTRyxhQUFhakIsSUFBSSxFQUFFa0IsUUFBUTtJQUNsQyxNQUFNakIsUUFBUSxFQUFFO0lBQ2hCLElBQUksT0FBT0QsU0FBUyxZQUFZLE9BQU9BLEtBQUtFLEtBQUssS0FBSyxVQUFVO1FBQzlELE9BQU9EO0lBQ1Q7SUFDQSxJQUFJRCxLQUFLbUIsU0FBUyxZQUFZQyxPQUFPO1FBQ25DcEIsS0FBS21CLFNBQVMsQ0FBQ1IsT0FBTyxDQUFDLENBQUNKO1lBQ3RCVyxTQUFTWCxNQUFNO1lBQ2ZOLE1BQU1vQixJQUFJLENBQUNkO1FBQ2I7SUFDRjtJQUNBLE1BQU1NLE9BQU9kLGFBQWFDO0lBQzFCLElBQUssTUFBTU8sUUFBUU0sS0FBTTtRQUN2QixNQUFNUyxPQUFPVCxJQUFJLENBQUNOLEtBQUs7UUFDdkIsSUFBSWUsTUFBTTtZQUNSSixTQUFTWCxNQUFNSyxvQkFBb0JaLE1BQU1PLE1BQU1lO1lBQy9DckIsTUFBTW9CLElBQUksQ0FBQ2Q7UUFDYjtJQUNGO0lBQ0EsT0FBT047QUFDVDtBQUVBLE1BQU1zQiwyQkFBMkI7SUFDL0JDLFVBQVU7SUFDVnJCLFNBQVMsQ0FBQztJQUNWZ0IsV0FBVyxDQUFDO0lBQ1osR0FBRzNDLHFCQUFxQjtBQUMxQjtBQUNBLFNBQVNpRCxtQkFBbUJILElBQUksRUFBRUksUUFBUTtJQUN4QyxJQUFLLE1BQU1DLFFBQVFELFNBQVU7UUFDM0IsSUFBSUMsUUFBUUwsUUFBUSxPQUFPQSxJQUFJLENBQUNLLEtBQUssS0FBSyxPQUFPRCxRQUFRLENBQUNDLEtBQUssRUFBRTtZQUMvRCxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNDLHVCQUF1QkMsR0FBRztJQUNqQyxJQUFJLE9BQU9BLFFBQVEsWUFBWUEsUUFBUSxNQUFNO1FBQzNDLE9BQU87SUFDVDtJQUNBLE1BQU03QixPQUFPNkI7SUFDYixJQUFJLE9BQU83QixLQUFLOEIsTUFBTSxLQUFLLFlBQVksQ0FBQ0QsSUFBSTNCLEtBQUssSUFBSSxPQUFPMkIsSUFBSTNCLEtBQUssS0FBSyxVQUFVO1FBQ2xGLE9BQU87SUFDVDtJQUNBLElBQUksQ0FBQ3VCLG1CQUFtQkksS0FBS04sMkJBQTJCO1FBQ3RELE9BQU87SUFDVDtJQUNBLE1BQU1yQixRQUFRRixLQUFLRSxLQUFLO0lBQ3hCLElBQUssTUFBTUssUUFBUUwsTUFBTztRQUN4QixNQUFNNkIsT0FBTzdCLEtBQUssQ0FBQ0ssS0FBSztRQUN4QixJQUNFLHVCQUF1QjtRQUN2QixDQUFDQSxRQUFRLGlCQUFpQjtRQUMxQixPQUFPd0IsS0FBSzFDLElBQUksS0FBSyxZQUFZLG9CQUFvQjtRQUNyRCxDQUFDb0MsbUJBQ0NNLE1BQ0EzQywyQkFFRjtZQUNBLE9BQU87UUFDVDtJQUNGO0lBQ0EsTUFBTWUsVUFBVUgsS0FBS0csT0FBTyxJQUFJLGFBQWEsR0FBRzFCLE9BQU8yQixNQUFNLENBQUM7SUFDOUQsSUFBSyxNQUFNRyxRQUFRSixRQUFTO1FBQzFCLE1BQU00QixPQUFPNUIsT0FBTyxDQUFDSSxLQUFLO1FBQzFCLE1BQU1YLFNBQVNtQyxLQUFLbkMsTUFBTTtRQUMxQixJQUNFLHVCQUF1QjtRQUN2QixDQUFDVyxRQUFRLGdEQUFnRDtRQUN6RCxPQUFPWCxXQUFXLFlBQVksQ0FBQ00sS0FBSyxDQUFDTixPQUFPLElBQUksQ0FBQ08sT0FBTyxDQUFDUCxPQUFPLElBQUksb0JBQW9CO1FBQ3hGLENBQUM2QixtQkFDQ00sTUFDQTNDLDJCQUVGO1lBQ0EsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPWTtBQUNUO0FBRUEsTUFBTWdDLGdCQUFnQjtBQUN0QixNQUFNQyxlQUFlLENBQUN6QixPQUFPMEIsVUFBVUMsaUJBQWlCWCxXQUFXLEVBQUU7SUFDbkUsTUFBTVksaUJBQWlCNUIsTUFBTTZCLEtBQUssQ0FBQztJQUNuQyxJQUFJN0IsTUFBTThCLEtBQUssQ0FBQyxHQUFHLE9BQU8sS0FBSztRQUM3QixJQUFJRixlQUFlRyxNQUFNLEdBQUcsS0FBS0gsZUFBZUcsTUFBTSxHQUFHLEdBQUc7WUFDMUQsT0FBTztRQUNUO1FBQ0FmLFdBQVdZLGVBQWVJLEtBQUssR0FBR0YsS0FBSyxDQUFDO0lBQzFDO0lBQ0EsSUFBSUYsZUFBZUcsTUFBTSxHQUFHLEtBQUssQ0FBQ0gsZUFBZUcsTUFBTSxFQUFFO1FBQ3ZELE9BQU87SUFDVDtJQUNBLElBQUlILGVBQWVHLE1BQU0sR0FBRyxHQUFHO1FBQzdCLE1BQU12QixRQUFRb0IsZUFBZUssR0FBRztRQUNoQyxNQUFNWCxTQUFTTSxlQUFlSyxHQUFHO1FBQ2pDLE1BQU0vQyxTQUFTO1lBQ2IscURBQXFEO1lBQ3JEOEIsVUFBVVksZUFBZUcsTUFBTSxHQUFHLElBQUlILGNBQWMsQ0FBQyxFQUFFLEdBQUdaO1lBQzFETTtZQUNBdkIsTUFBTVM7UUFDUjtRQUNBLE9BQU9rQixZQUFZLENBQUNRLGlCQUFpQmhELFVBQVUsT0FBT0E7SUFDeEQ7SUFDQSxNQUFNYSxPQUFPNkIsY0FBYyxDQUFDLEVBQUU7SUFDOUIsTUFBTU8sZ0JBQWdCcEMsS0FBSzhCLEtBQUssQ0FBQztJQUNqQyxJQUFJTSxjQUFjSixNQUFNLEdBQUcsR0FBRztRQUM1QixNQUFNN0MsU0FBUztZQUNiOEI7WUFDQU0sUUFBUWEsY0FBY0gsS0FBSztZQUMzQmpDLE1BQU1vQyxjQUFjQyxJQUFJLENBQUM7UUFDM0I7UUFDQSxPQUFPVixZQUFZLENBQUNRLGlCQUFpQmhELFVBQVUsT0FBT0E7SUFDeEQ7SUFDQSxJQUFJeUMsbUJBQW1CWCxhQUFhLElBQUk7UUFDdEMsTUFBTTlCLFNBQVM7WUFDYjhCO1lBQ0FNLFFBQVE7WUFDUnZCO1FBQ0Y7UUFDQSxPQUFPMkIsWUFBWSxDQUFDUSxpQkFBaUJoRCxRQUFReUMsbUJBQW1CLE9BQU96QztJQUN6RTtJQUNBLE9BQU87QUFDVDtBQUNBLE1BQU1nRCxtQkFBbUIsQ0FBQ1gsTUFBTUk7SUFDOUIsSUFBSSxDQUFDSixNQUFNO1FBQ1QsT0FBTztJQUNUO0lBQ0EsT0FBTyxDQUFDLENBQ1IsOEJBQThCO0lBQzdCLEVBQUNJLG1CQUFtQkosS0FBS0QsTUFBTSxLQUFLLE1BQU0sQ0FBQyxDQUFDQyxLQUFLRCxNQUFNLEtBQUssQ0FBQyxDQUFDQyxLQUFLeEIsSUFBSTtBQUMxRTtBQUVBLE1BQU1zQyxjQUFjLGFBQWEsR0FBR3BFLE9BQU8yQixNQUFNLENBQUM7QUFDbEQsU0FBUzBDLFdBQVd0QixRQUFRLEVBQUVNLE1BQU07SUFDbEMsT0FBTztRQUNMTjtRQUNBTTtRQUNBNUIsT0FBTyxhQUFhLEdBQUd6QixPQUFPMkIsTUFBTSxDQUFDO1FBQ3JDMkMsU0FBUyxhQUFhLEdBQUcsSUFBSUM7SUFDL0I7QUFDRjtBQUNBLFNBQVNDLFdBQVd6QixRQUFRLEVBQUVNLE1BQU07SUFDbEMsTUFBTW9CLGtCQUFrQkwsV0FBVyxDQUFDckIsU0FBUyxJQUFLcUIsQ0FBQUEsV0FBVyxDQUFDckIsU0FBUyxHQUFHLGFBQWEsR0FBRy9DLE9BQU8yQixNQUFNLENBQUMsS0FBSTtJQUM1RyxPQUFPOEMsZUFBZSxDQUFDcEIsT0FBTyxJQUFLb0IsQ0FBQUEsZUFBZSxDQUFDcEIsT0FBTyxHQUFHZ0IsV0FBV3RCLFVBQVVNLE9BQU07QUFDMUY7QUFDQSxTQUFTcUIsV0FBV0MsT0FBTyxFQUFFcEQsSUFBSTtJQUMvQixJQUFJLENBQUM0Qix1QkFBdUI1QixPQUFPO1FBQ2pDLE9BQU8sRUFBRTtJQUNYO0lBQ0EsT0FBT2lCLGFBQWFqQixNQUFNLENBQUNPLE1BQU13QjtRQUMvQixJQUFJQSxNQUFNO1lBQ1JxQixRQUFRbEQsS0FBSyxDQUFDSyxLQUFLLEdBQUd3QjtRQUN4QixPQUFPO1lBQ0xxQixRQUFRTCxPQUFPLENBQUNNLEdBQUcsQ0FBQzlDO1FBQ3RCO0lBQ0Y7QUFDRjtBQUNBLFNBQVMrQyxpQkFBaUJGLE9BQU8sRUFBRTdDLElBQUksRUFBRXdCLElBQUk7SUFDM0MsSUFBSTtRQUNGLElBQUksT0FBT0EsS0FBSzFDLElBQUksS0FBSyxVQUFVO1lBQ2pDK0QsUUFBUWxELEtBQUssQ0FBQ0ssS0FBSyxHQUFHO2dCQUFFLEdBQUd3QixJQUFJO1lBQUM7WUFDaEMsT0FBTztRQUNUO0lBQ0YsRUFBRSxPQUFPd0IsS0FBSyxDQUNkO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU0MsVUFBVWhDLFFBQVEsRUFBRU0sTUFBTTtJQUNqQyxJQUFJMkIsV0FBVyxFQUFFO0lBQ2pCLE1BQU1DLFlBQVksT0FBT2xDLGFBQWEsV0FBVztRQUFDQTtLQUFTLEdBQUcvQyxPQUFPaUMsSUFBSSxDQUFDbUM7SUFDMUVhLFVBQVUvQyxPQUFPLENBQUMsQ0FBQ2dEO1FBQ2pCLE1BQU1DLFdBQVcsT0FBT0QsY0FBYyxZQUFZLE9BQU83QixXQUFXLFdBQVc7WUFBQ0E7U0FBTyxHQUFHckQsT0FBT2lDLElBQUksQ0FBQ21DLFdBQVcsQ0FBQ2MsVUFBVSxJQUFJLENBQUM7UUFDaklDLFNBQVNqRCxPQUFPLENBQUMsQ0FBQ2tEO1lBQ2hCLE1BQU1ULFVBQVVILFdBQVdVLFdBQVdFO1lBQ3RDSixXQUFXQSxTQUFTaEQsTUFBTSxDQUN4QmhDLE9BQU9pQyxJQUFJLENBQUMwQyxRQUFRbEQsS0FBSyxFQUFFNEQsR0FBRyxDQUM1QixDQUFDdkQsT0FBUyxDQUFDb0QsY0FBYyxLQUFLLE1BQU1BLFlBQVksTUFBTSxFQUFDLElBQUtFLFVBQVUsTUFBTXREO1FBR2xGO0lBQ0Y7SUFDQSxPQUFPa0Q7QUFDVDtBQUVBLElBQUlNLGNBQWM7QUFDbEIsU0FBU0MsaUJBQWlCQyxLQUFLO0lBQzdCLElBQUksT0FBT0EsVUFBVSxXQUFXO1FBQzlCRixjQUFjRTtJQUNoQjtJQUNBLE9BQU9GO0FBQ1Q7QUFDQSxTQUFTRyxZQUFZM0QsSUFBSTtJQUN2QixNQUFNd0IsT0FBTyxPQUFPeEIsU0FBUyxXQUFXMEIsYUFBYTFCLE1BQU0sTUFBTXdELGVBQWV4RDtJQUNoRixJQUFJd0IsTUFBTTtRQUNSLE1BQU1xQixVQUFVSCxXQUFXbEIsS0FBS1AsUUFBUSxFQUFFTyxLQUFLRCxNQUFNO1FBQ3JELE1BQU1xQyxXQUFXcEMsS0FBS3hCLElBQUk7UUFDMUIsT0FBTzZDLFFBQVFsRCxLQUFLLENBQUNpRSxTQUFTLElBQUtmLENBQUFBLFFBQVFMLE9BQU8sQ0FBQ3FCLEdBQUcsQ0FBQ0QsWUFBWSxPQUFPLEtBQUs7SUFDakY7QUFDRjtBQUNBLFNBQVNFLFFBQVE5RCxJQUFJLEVBQUVQLElBQUk7SUFDekIsTUFBTStCLE9BQU9FLGFBQWExQixNQUFNLE1BQU13RDtJQUN0QyxJQUFJLENBQUNoQyxNQUFNO1FBQ1QsT0FBTztJQUNUO0lBQ0EsTUFBTXFCLFVBQVVILFdBQVdsQixLQUFLUCxRQUFRLEVBQUVPLEtBQUtELE1BQU07SUFDckQsSUFBSTlCLE1BQU07UUFDUixPQUFPc0QsaUJBQWlCRixTQUFTckIsS0FBS3hCLElBQUksRUFBRVA7SUFDOUMsT0FBTztRQUNMb0QsUUFBUUwsT0FBTyxDQUFDTSxHQUFHLENBQUN0QixLQUFLeEIsSUFBSTtRQUM3QixPQUFPO0lBQ1Q7QUFDRjtBQUNBLFNBQVMrRCxjQUFjdEUsSUFBSSxFQUFFd0IsUUFBUTtJQUNuQyxJQUFJLE9BQU94QixTQUFTLFVBQVU7UUFDNUIsT0FBTztJQUNUO0lBQ0EsSUFBSSxPQUFPd0IsYUFBYSxVQUFVO1FBQ2hDQSxXQUFXeEIsS0FBS3dCLFFBQVEsSUFBSTtJQUM5QjtJQUNBLElBQUl1QyxlQUFlLENBQUN2QyxZQUFZLENBQUN4QixLQUFLOEIsTUFBTSxFQUFFO1FBQzVDLElBQUl5QyxRQUFRO1FBQ1osSUFBSTNDLHVCQUF1QjVCLE9BQU87WUFDaENBLEtBQUs4QixNQUFNLEdBQUc7WUFDZGIsYUFBYWpCLE1BQU0sQ0FBQ08sTUFBTXdCO2dCQUN4QixJQUFJc0MsUUFBUTlELE1BQU13QixPQUFPO29CQUN2QndDLFFBQVE7Z0JBQ1Y7WUFDRjtRQUNGO1FBQ0EsT0FBT0E7SUFDVDtJQUNBLE1BQU16QyxTQUFTOUIsS0FBSzhCLE1BQU07SUFDMUIsSUFBSSxDQUFDWSxpQkFBaUI7UUFDcEJaO1FBQ0F2QixNQUFNO0lBQ1IsSUFBSTtRQUNGLE9BQU87SUFDVDtJQUNBLE1BQU02QyxVQUFVSCxXQUFXekIsVUFBVU07SUFDckMsT0FBTyxDQUFDLENBQUNxQixXQUFXQyxTQUFTcEQ7QUFDL0I7QUFDQSxTQUFTd0UsV0FBV2pFLElBQUk7SUFDdEIsT0FBTyxDQUFDLENBQUMyRCxZQUFZM0Q7QUFDdkI7QUFDQSxTQUFTa0UsUUFBUWxFLElBQUk7SUFDbkIsTUFBTWIsU0FBU3dFLFlBQVkzRDtJQUMzQixPQUFPYixTQUFTO1FBQ2QsR0FBR1AsZ0JBQWdCO1FBQ25CLEdBQUdPLE1BQU07SUFDWCxJQUFJQTtBQUNOO0FBRUEsTUFBTWdGLGdDQUFnQ2pHLE9BQU9DLE1BQU0sQ0FBQztJQUNsREcsT0FBTztJQUNQQyxRQUFRO0FBQ1Y7QUFDQSxNQUFNNkYsNEJBQTRCbEcsT0FBT0MsTUFBTSxDQUFDO0lBQzlDLGFBQWE7SUFDYixHQUFHZ0csNkJBQTZCO0lBQ2hDLGtCQUFrQjtJQUNsQixHQUFHM0YsMEJBQTBCO0FBQy9CO0FBRUEsTUFBTTZGLGFBQWE7QUFDbkIsTUFBTUMsWUFBWTtBQUNsQixTQUFTQyxjQUFjQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsU0FBUztJQUMzQyxJQUFJRCxVQUFVLEdBQUc7UUFDZixPQUFPRDtJQUNUO0lBQ0FFLFlBQVlBLGFBQWE7SUFDekIsSUFBSSxPQUFPRixTQUFTLFVBQVU7UUFDNUIsT0FBT0csS0FBS0MsSUFBSSxDQUFDSixPQUFPQyxRQUFRQyxhQUFhQTtJQUMvQztJQUNBLElBQUksT0FBT0YsU0FBUyxVQUFVO1FBQzVCLE9BQU9BO0lBQ1Q7SUFDQSxNQUFNSyxXQUFXTCxLQUFLMUMsS0FBSyxDQUFDdUM7SUFDNUIsSUFBSVEsYUFBYSxRQUFRLENBQUNBLFNBQVM3QyxNQUFNLEVBQUU7UUFDekMsT0FBT3dDO0lBQ1Q7SUFDQSxNQUFNTSxXQUFXLEVBQUU7SUFDbkIsSUFBSUMsT0FBT0YsU0FBUzVDLEtBQUs7SUFDekIsSUFBSStDLFdBQVdWLFVBQVVXLElBQUksQ0FBQ0Y7SUFDOUIsTUFBTyxLQUFNO1FBQ1gsSUFBSUMsVUFBVTtZQUNaLE1BQU1FLE1BQU1DLFdBQVdKO1lBQ3ZCLElBQUlLLE1BQU1GLE1BQU07Z0JBQ2RKLFNBQVNoRSxJQUFJLENBQUNpRTtZQUNoQixPQUFPO2dCQUNMRCxTQUFTaEUsSUFBSSxDQUFDNkQsS0FBS0MsSUFBSSxDQUFDTSxNQUFNVCxRQUFRQyxhQUFhQTtZQUNyRDtRQUNGLE9BQU87WUFDTEksU0FBU2hFLElBQUksQ0FBQ2lFO1FBQ2hCO1FBQ0FBLE9BQU9GLFNBQVM1QyxLQUFLO1FBQ3JCLElBQUk4QyxTQUFTLEtBQUssR0FBRztZQUNuQixPQUFPRCxTQUFTekMsSUFBSSxDQUFDO1FBQ3ZCO1FBQ0EyQyxXQUFXLENBQUNBO0lBQ2Q7QUFDRjtBQUVBLFNBQVNLLGFBQWFDLE9BQU8sRUFBRUMsTUFBTSxNQUFNO0lBQ3pDLElBQUlDLE9BQU87SUFDWCxNQUFNQyxRQUFRSCxRQUFRSSxPQUFPLENBQUMsTUFBTUg7SUFDcEMsTUFBT0UsU0FBUyxFQUFHO1FBQ2pCLE1BQU1FLFFBQVFMLFFBQVFJLE9BQU8sQ0FBQyxLQUFLRDtRQUNuQyxNQUFNRyxNQUFNTixRQUFRSSxPQUFPLENBQUMsT0FBT0g7UUFDbkMsSUFBSUksVUFBVSxDQUFDLEtBQUtDLFFBQVEsQ0FBQyxHQUFHO1lBQzlCO1FBQ0Y7UUFDQSxNQUFNQyxTQUFTUCxRQUFRSSxPQUFPLENBQUMsS0FBS0U7UUFDcEMsSUFBSUMsV0FBVyxDQUFDLEdBQUc7WUFDakI7UUFDRjtRQUNBTCxRQUFRRixRQUFRdkQsS0FBSyxDQUFDNEQsUUFBUSxHQUFHQyxLQUFLRSxJQUFJO1FBQzFDUixVQUFVQSxRQUFRdkQsS0FBSyxDQUFDLEdBQUcwRCxPQUFPSyxJQUFJLEtBQUtSLFFBQVF2RCxLQUFLLENBQUM4RCxTQUFTO0lBQ3BFO0lBQ0EsT0FBTztRQUNMTDtRQUNBRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTUyxvQkFBb0JQLElBQUksRUFBRUYsT0FBTztJQUN4QyxPQUFPRSxPQUFPLFdBQVdBLE9BQU8sWUFBWUYsVUFBVUE7QUFDeEQ7QUFDQSxTQUFTVSxlQUFlbEgsSUFBSSxFQUFFNkcsS0FBSyxFQUFFQyxHQUFHO0lBQ3RDLE1BQU05RCxRQUFRdUQsYUFBYXZHO0lBQzNCLE9BQU9pSCxvQkFBb0JqRSxNQUFNMEQsSUFBSSxFQUFFRyxRQUFRN0QsTUFBTXdELE9BQU8sR0FBR007QUFDakU7QUFFQSxNQUFNSyxpQkFBaUIsQ0FBQ2hHLFFBQVVBLFVBQVUsV0FBV0EsVUFBVSxlQUFlQSxVQUFVO0FBQzFGLFNBQVNpRyxVQUFVMUUsSUFBSSxFQUFFMkUsY0FBYztJQUNyQyxNQUFNQyxXQUFXO1FBQ2YsR0FBR3hILGdCQUFnQjtRQUNuQixHQUFHNEMsSUFBSTtJQUNUO0lBQ0EsTUFBTTZFLHFCQUFxQjtRQUN6QixHQUFHakMseUJBQXlCO1FBQzVCLEdBQUcrQixjQUFjO0lBQ25CO0lBQ0EsTUFBTUcsTUFBTTtRQUNWbEksTUFBTWdJLFNBQVNoSSxJQUFJO1FBQ25CQyxLQUFLK0gsU0FBUy9ILEdBQUc7UUFDakJDLE9BQU84SCxTQUFTOUgsS0FBSztRQUNyQkMsUUFBUTZILFNBQVM3SCxNQUFNO0lBQ3pCO0lBQ0EsSUFBSU8sT0FBT3NILFNBQVN0SCxJQUFJO0lBQ3hCO1FBQUNzSDtRQUFVQztLQUFtQixDQUFDakcsT0FBTyxDQUFDLENBQUNtRztRQUN0QyxNQUFNQyxrQkFBa0IsRUFBRTtRQUMxQixNQUFNN0gsUUFBUTRILE1BQU01SCxLQUFLO1FBQ3pCLE1BQU1ELFFBQVE2SCxNQUFNN0gsS0FBSztRQUN6QixJQUFJK0gsV0FBV0YsTUFBTTlILE1BQU07UUFDM0IsSUFBSUUsT0FBTztZQUNULElBQUlELE9BQU87Z0JBQ1QrSCxZQUFZO1lBQ2QsT0FBTztnQkFDTEQsZ0JBQWdCMUYsSUFBSSxDQUNsQixlQUFlLENBQUN3RixJQUFJaEksS0FBSyxHQUFHZ0ksSUFBSWxJLElBQUksRUFBRXNJLFFBQVEsS0FBSyxNQUFNLENBQUMsSUFBSUosSUFBSWpJLEdBQUcsRUFBRXFJLFFBQVEsS0FBSztnQkFFdEZGLGdCQUFnQjFGLElBQUksQ0FBQztnQkFDckJ3RixJQUFJakksR0FBRyxHQUFHaUksSUFBSWxJLElBQUksR0FBRztZQUN2QjtRQUNGLE9BQU8sSUFBSU0sT0FBTztZQUNoQjhILGdCQUFnQjFGLElBQUksQ0FDbEIsZUFBZSxDQUFDLElBQUl3RixJQUFJbEksSUFBSSxFQUFFc0ksUUFBUSxLQUFLLE1BQU0sQ0FBQ0osSUFBSS9ILE1BQU0sR0FBRytILElBQUlqSSxHQUFHLEVBQUVxSSxRQUFRLEtBQUs7WUFFdkZGLGdCQUFnQjFGLElBQUksQ0FBQztZQUNyQndGLElBQUlqSSxHQUFHLEdBQUdpSSxJQUFJbEksSUFBSSxHQUFHO1FBQ3ZCO1FBQ0EsSUFBSXVJO1FBQ0osSUFBSUYsV0FBVyxHQUFHO1lBQ2hCQSxZQUFZOUIsS0FBS2lDLEtBQUssQ0FBQ0gsV0FBVyxLQUFLO1FBQ3pDO1FBQ0FBLFdBQVdBLFdBQVc7UUFDdEIsT0FBUUE7WUFDTixLQUFLO2dCQUNIRSxZQUFZTCxJQUFJL0gsTUFBTSxHQUFHLElBQUkrSCxJQUFJakksR0FBRztnQkFDcENtSSxnQkFBZ0JLLE9BQU8sQ0FDckIsZUFBZUYsVUFBVUQsUUFBUSxLQUFLLE1BQU1DLFVBQVVELFFBQVEsS0FBSztnQkFFckU7WUFDRixLQUFLO2dCQUNIRixnQkFBZ0JLLE9BQU8sQ0FDckIsZ0JBQWdCLENBQUNQLElBQUloSSxLQUFLLEdBQUcsSUFBSWdJLElBQUlsSSxJQUFJLEVBQUVzSSxRQUFRLEtBQUssTUFBTSxDQUFDSixJQUFJL0gsTUFBTSxHQUFHLElBQUkrSCxJQUFJakksR0FBRyxFQUFFcUksUUFBUSxLQUFLO2dCQUV4RztZQUNGLEtBQUs7Z0JBQ0hDLFlBQVlMLElBQUloSSxLQUFLLEdBQUcsSUFBSWdJLElBQUlsSSxJQUFJO2dCQUNwQ29JLGdCQUFnQkssT0FBTyxDQUNyQixnQkFBZ0JGLFVBQVVELFFBQVEsS0FBSyxNQUFNQyxVQUFVRCxRQUFRLEtBQUs7Z0JBRXRFO1FBQ0o7UUFDQSxJQUFJRCxXQUFXLE1BQU0sR0FBRztZQUN0QixJQUFJSCxJQUFJbEksSUFBSSxLQUFLa0ksSUFBSWpJLEdBQUcsRUFBRTtnQkFDeEJzSSxZQUFZTCxJQUFJbEksSUFBSTtnQkFDcEJrSSxJQUFJbEksSUFBSSxHQUFHa0ksSUFBSWpJLEdBQUc7Z0JBQ2xCaUksSUFBSWpJLEdBQUcsR0FBR3NJO1lBQ1o7WUFDQSxJQUFJTCxJQUFJaEksS0FBSyxLQUFLZ0ksSUFBSS9ILE1BQU0sRUFBRTtnQkFDNUJvSSxZQUFZTCxJQUFJaEksS0FBSztnQkFDckJnSSxJQUFJaEksS0FBSyxHQUFHZ0ksSUFBSS9ILE1BQU07Z0JBQ3RCK0gsSUFBSS9ILE1BQU0sR0FBR29JO1lBQ2Y7UUFDRjtRQUNBLElBQUlILGdCQUFnQnhFLE1BQU0sRUFBRTtZQUMxQmxELE9BQU9rSCxlQUNMbEgsTUFDQSxtQkFBbUIwSCxnQkFBZ0JuRSxJQUFJLENBQUMsT0FBTyxNQUMvQztRQUVKO0lBQ0Y7SUFDQSxNQUFNeUUsc0JBQXNCVCxtQkFBbUIvSCxLQUFLO0lBQ3BELE1BQU15SSx1QkFBdUJWLG1CQUFtQjlILE1BQU07SUFDdEQsTUFBTXlJLFdBQVdWLElBQUloSSxLQUFLO0lBQzFCLE1BQU0ySSxZQUFZWCxJQUFJL0gsTUFBTTtJQUM1QixJQUFJRDtJQUNKLElBQUlDO0lBQ0osSUFBSXVJLHdCQUF3QixNQUFNO1FBQ2hDdkksU0FBU3dJLHlCQUF5QixPQUFPLFFBQVFBLHlCQUF5QixTQUFTRSxZQUFZRjtRQUMvRnpJLFFBQVFpRyxjQUFjaEcsUUFBUXlJLFdBQVdDO0lBQzNDLE9BQU87UUFDTDNJLFFBQVF3SSx3QkFBd0IsU0FBU0UsV0FBV0Y7UUFDcER2SSxTQUFTd0kseUJBQXlCLE9BQU94QyxjQUFjakcsT0FBTzJJLFlBQVlELFlBQVlELHlCQUF5QixTQUFTRSxZQUFZRjtJQUN0STtJQUNBLE1BQU1HLGFBQWEsQ0FBQztJQUNwQixNQUFNQyxVQUFVLENBQUMvRixNQUFNbkI7UUFDckIsSUFBSSxDQUFDZ0csZUFBZWhHLFFBQVE7WUFDMUJpSCxVQUFVLENBQUM5RixLQUFLLEdBQUduQixNQUFNeUcsUUFBUTtRQUNuQztJQUNGO0lBQ0FTLFFBQVEsU0FBUzdJO0lBQ2pCNkksUUFBUSxVQUFVNUk7SUFDbEIsTUFBTTZJLFVBQVU7UUFBQ2QsSUFBSWxJLElBQUk7UUFBRWtJLElBQUlqSSxHQUFHO1FBQUUySTtRQUFVQztLQUFVO0lBQ3hEQyxXQUFXRSxPQUFPLEdBQUdBLFFBQVEvRSxJQUFJLENBQUM7SUFDbEMsT0FBTztRQUNMNkU7UUFDQUU7UUFDQXRJO0lBQ0Y7QUFDRjtBQUVBLE1BQU11SSxRQUFRO0FBQ2QsTUFBTUMsZUFBZSxjQUFjQyxLQUFLQyxHQUFHLEdBQUdkLFFBQVEsQ0FBQyxNQUFNLENBQUMvQixLQUFLOEMsTUFBTSxLQUFLLFdBQVcsR0FBR2YsUUFBUSxDQUFDO0FBQ3JHLElBQUlnQixVQUFVO0FBQ2QsU0FBU0MsV0FBVzdJLElBQUksRUFBRXlDLFNBQVMrRixZQUFZO0lBQzdDLE1BQU1NLE1BQU0sRUFBRTtJQUNkLElBQUlDO0lBQ0osTUFBT0EsUUFBUVIsTUFBTVMsSUFBSSxDQUFDaEosTUFBTztRQUMvQjhJLElBQUk5RyxJQUFJLENBQUMrRyxLQUFLLENBQUMsRUFBRTtJQUNuQjtJQUNBLElBQUksQ0FBQ0QsSUFBSTVGLE1BQU0sRUFBRTtRQUNmLE9BQU9sRDtJQUNUO0lBQ0EsTUFBTWlKLFNBQVMsV0FBVyxDQUFDcEQsS0FBSzhDLE1BQU0sS0FBSyxXQUFXRixLQUFLQyxHQUFHLEVBQUMsRUFBR2QsUUFBUSxDQUFDO0lBQzNFa0IsSUFBSXhILE9BQU8sQ0FBQyxDQUFDNEg7UUFDWCxNQUFNQyxRQUFRLE9BQU8xRyxXQUFXLGFBQWFBLE9BQU95RyxNQUFNekcsU0FBUyxDQUFDbUcsU0FBUSxFQUFHaEIsUUFBUTtRQUN2RixNQUFNd0IsWUFBWUYsR0FBR0csT0FBTyxDQUFDLHVCQUF1QjtRQUNwRHJKLE9BQU9BLEtBQUtxSixPQUFPLENBQ2pCLHNDQUFzQztRQUN0Qyw0Q0FBNEM7UUFDNUMsSUFBSUMsT0FBTyxhQUFhRixZQUFZLG9CQUFvQixNQUN4RCxPQUFPRCxRQUFRRixTQUFTO0lBRTVCO0lBQ0FqSixPQUFPQSxLQUFLcUosT0FBTyxDQUFDLElBQUlDLE9BQU9MLFFBQVEsTUFBTTtJQUM3QyxPQUFPako7QUFDVDtBQUVBLE1BQU0rRCxVQUFVLGFBQWEsR0FBRzNFLE9BQU8yQixNQUFNLENBQUM7QUFDOUMsU0FBU3dJLGFBQWFwSCxRQUFRLEVBQUVGLElBQUk7SUFDbEM4QixPQUFPLENBQUM1QixTQUFTLEdBQUdGO0FBQ3RCO0FBQ0EsU0FBU3VILGFBQWFySCxRQUFRO0lBQzVCLE9BQU80QixPQUFPLENBQUM1QixTQUFTLElBQUk0QixPQUFPLENBQUMsR0FBRztBQUN6QztBQUVBLFNBQVMwRixnQkFBZ0JDLE1BQU07SUFDN0IsSUFBSUM7SUFDSixJQUFJLE9BQU9ELE9BQU9DLFNBQVMsS0FBSyxVQUFVO1FBQ3hDQSxZQUFZO1lBQUNELE9BQU9DLFNBQVM7U0FBQztJQUNoQyxPQUFPO1FBQ0xBLFlBQVlELE9BQU9DLFNBQVM7UUFDNUIsSUFBSSxDQUFFQSxDQUFBQSxxQkFBcUI1SCxLQUFJLEtBQU0sQ0FBQzRILFVBQVV6RyxNQUFNLEVBQUU7WUFDdEQsT0FBTztRQUNUO0lBQ0Y7SUFDQSxNQUFNN0MsU0FBUztRQUNiLFlBQVk7UUFDWnNKO1FBQ0EsWUFBWTtRQUNaQyxNQUFNRixPQUFPRSxJQUFJLElBQUk7UUFDckIsbUJBQW1CO1FBQ25CQyxRQUFRSCxPQUFPRyxNQUFNLElBQUk7UUFDekIsb0NBQW9DO1FBQ3BDbEssUUFBUStKLE9BQU8vSixNQUFNLElBQUk7UUFDekIsZ0NBQWdDO1FBQ2hDbUssU0FBU0osT0FBT0ksT0FBTyxJQUFJO1FBQzNCLG1DQUFtQztRQUNuQ25CLFFBQVFlLE9BQU9mLE1BQU0sS0FBSztRQUMxQixjQUFjO1FBQ2RoQyxPQUFPK0MsT0FBTy9DLEtBQUssSUFBSTtRQUN2QixvR0FBb0c7UUFDcEdvRCxrQkFBa0JMLE9BQU9LLGdCQUFnQixLQUFLO0lBQ2hEO0lBQ0EsT0FBTzFKO0FBQ1Q7QUFDQSxNQUFNMkosZ0JBQWdCLGFBQWEsR0FBRzVLLE9BQU8yQixNQUFNLENBQUM7QUFDcEQsTUFBTWtKLHFCQUFxQjtJQUN6QjtJQUNBO0NBQ0Q7QUFDRCxNQUFNQyxjQUFjLEVBQUU7QUFDdEIsTUFBT0QsbUJBQW1CL0csTUFBTSxHQUFHLEVBQUc7SUFDcEMsSUFBSStHLG1CQUFtQi9HLE1BQU0sS0FBSyxHQUFHO1FBQ25DZ0gsWUFBWWxJLElBQUksQ0FBQ2lJLG1CQUFtQjlHLEtBQUs7SUFDM0MsT0FBTztRQUNMLElBQUkwQyxLQUFLOEMsTUFBTSxLQUFLLEtBQUs7WUFDdkJ1QixZQUFZbEksSUFBSSxDQUFDaUksbUJBQW1COUcsS0FBSztRQUMzQyxPQUFPO1lBQ0wrRyxZQUFZbEksSUFBSSxDQUFDaUksbUJBQW1CN0csR0FBRztRQUN6QztJQUNGO0FBQ0Y7QUFDQTRHLGFBQWEsQ0FBQyxHQUFHLEdBQUdQLGdCQUFnQjtJQUNsQ0UsV0FBVztRQUFDO0tBQTZCLENBQUN2SSxNQUFNLENBQUM4STtBQUNuRDtBQUNBLFNBQVNDLGVBQWVoSSxRQUFRLEVBQUVpSSxZQUFZO0lBQzVDLE1BQU1DLFNBQVNaLGdCQUFnQlc7SUFDL0IsSUFBSUMsV0FBVyxNQUFNO1FBQ25CLE9BQU87SUFDVDtJQUNBTCxhQUFhLENBQUM3SCxTQUFTLEdBQUdrSTtJQUMxQixPQUFPO0FBQ1Q7QUFDQSxTQUFTQyxhQUFhbkksUUFBUTtJQUM1QixPQUFPNkgsYUFBYSxDQUFDN0gsU0FBUztBQUNoQztBQUNBLFNBQVNvSTtJQUNQLE9BQU9uTCxPQUFPaUMsSUFBSSxDQUFDMkk7QUFDckI7QUFFQSxNQUFNUSxjQUFjO0lBQ2xCLElBQUkzSTtJQUNKLElBQUk7UUFDRkEsV0FBVzRJO1FBQ1gsSUFBSSxPQUFPNUksYUFBYSxZQUFZO1lBQ2xDLE9BQU9BO1FBQ1Q7SUFDRixFQUFFLE9BQU9xQyxLQUFLLENBQ2Q7QUFDRjtBQUNBLElBQUl3RyxjQUFjRjtBQUNsQixTQUFTRyxTQUFTQyxNQUFNO0lBQ3RCRixjQUFjRTtBQUNoQjtBQUNBLFNBQVNDO0lBQ1AsT0FBT0g7QUFDVDtBQUNBLFNBQVNJLG1CQUFtQjNJLFFBQVEsRUFBRU0sTUFBTTtJQUMxQyxNQUFNNEgsU0FBU0MsYUFBYW5JO0lBQzVCLElBQUksQ0FBQ2tJLFFBQVE7UUFDWCxPQUFPO0lBQ1Q7SUFDQSxJQUFJaEs7SUFDSixJQUFJLENBQUNnSyxPQUFPUixNQUFNLEVBQUU7UUFDbEJ4SixTQUFTO0lBQ1gsT0FBTztRQUNMLElBQUkwSyxnQkFBZ0I7UUFDcEJWLE9BQU9WLFNBQVMsQ0FBQ3JJLE9BQU8sQ0FBQyxDQUFDVztZQUN4QixNQUFNK0ksT0FBTy9JO1lBQ2I4SSxnQkFBZ0JsRixLQUFLb0YsR0FBRyxDQUFDRixlQUFlQyxLQUFLOUgsTUFBTTtRQUNyRDtRQUNBLE1BQU1nSSxNQUFNekksU0FBUztRQUNyQnBDLFNBQVNnSyxPQUFPUixNQUFNLEdBQUdrQixnQkFBZ0JWLE9BQU9ULElBQUksQ0FBQzFHLE1BQU0sR0FBR2dJLElBQUloSSxNQUFNO0lBQzFFO0lBQ0EsT0FBTzdDO0FBQ1Q7QUFDQSxTQUFTOEssWUFBWUMsTUFBTTtJQUN6QixPQUFPQSxXQUFXO0FBQ3BCO0FBQ0EsTUFBTUMsVUFBVSxDQUFDbEosVUFBVU0sUUFBUTVCO0lBQ2pDLE1BQU15SyxVQUFVLEVBQUU7SUFDbEIsTUFBTUMsWUFBWVQsbUJBQW1CM0ksVUFBVU07SUFDL0MsTUFBTStJLE9BQU87SUFDYixJQUFJdkosT0FBTztRQUNUdUo7UUFDQXJKO1FBQ0FNO1FBQ0E1QixPQUFPLEVBQUU7SUFDWDtJQUNBLElBQUlxQyxTQUFTO0lBQ2JyQyxNQUFNUyxPQUFPLENBQUMsQ0FBQ0osTUFBTXlGO1FBQ25CekQsVUFBVWhDLEtBQUtnQyxNQUFNLEdBQUc7UUFDeEIsSUFBSUEsVUFBVXFJLGFBQWE1RSxRQUFRLEdBQUc7WUFDcEMyRSxRQUFRdEosSUFBSSxDQUFDQztZQUNiQSxPQUFPO2dCQUNMdUo7Z0JBQ0FySjtnQkFDQU07Z0JBQ0E1QixPQUFPLEVBQUU7WUFDWDtZQUNBcUMsU0FBU2hDLEtBQUtnQyxNQUFNO1FBQ3RCO1FBQ0FqQixLQUFLcEIsS0FBSyxDQUFDbUIsSUFBSSxDQUFDZDtJQUNsQjtJQUNBb0ssUUFBUXRKLElBQUksQ0FBQ0M7SUFDYixPQUFPcUo7QUFDVDtBQUNBLFNBQVNHLFFBQVF0SixRQUFRO0lBQ3ZCLElBQUksT0FBT0EsYUFBYSxVQUFVO1FBQ2hDLE1BQU1rSSxTQUFTQyxhQUFhbkk7UUFDNUIsSUFBSWtJLFFBQVE7WUFDVixPQUFPQSxPQUFPVCxJQUFJO1FBQ3BCO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxNQUFNOEIsT0FBTyxDQUFDVixNQUFNVyxRQUFROUo7SUFDMUIsSUFBSSxDQUFDNkksYUFBYTtRQUNoQjdJLFNBQVMsU0FBUztRQUNsQjtJQUNGO0lBQ0EsSUFBSStILE9BQU82QixRQUFRRSxPQUFPeEosUUFBUTtJQUNsQyxPQUFRd0osT0FBT0gsSUFBSTtRQUNqQixLQUFLO1lBQVM7Z0JBQ1osTUFBTS9JLFNBQVNrSixPQUFPbEosTUFBTTtnQkFDNUIsTUFBTTVCLFFBQVE4SyxPQUFPOUssS0FBSztnQkFDMUIsTUFBTStLLFlBQVkvSyxNQUFNMEMsSUFBSSxDQUFDO2dCQUM3QixNQUFNc0ksWUFBWSxJQUFJQyxnQkFBZ0I7b0JBQ3BDakwsT0FBTytLO2dCQUNUO2dCQUNBaEMsUUFBUW5ILFNBQVMsV0FBV29KLFVBQVVqRSxRQUFRO2dCQUM5QztZQUNGO1FBQ0EsS0FBSztZQUFVO2dCQUNiLE1BQU1tRSxNQUFNSixPQUFPSSxHQUFHO2dCQUN0Qm5DLFFBQVFtQyxJQUFJOUksS0FBSyxDQUFDLEdBQUcsT0FBTyxNQUFNOEksSUFBSTlJLEtBQUssQ0FBQyxLQUFLOEk7Z0JBQ2pEO1lBQ0Y7UUFDQTtZQUNFbEssU0FBUyxTQUFTO1lBQ2xCO0lBQ0o7SUFDQSxJQUFJbUssZUFBZTtJQUNuQnRCLFlBQVlNLE9BQU9wQixNQUFNcUMsSUFBSSxDQUFDLENBQUNDO1FBQzdCLE1BQU1kLFNBQVNjLFNBQVNkLE1BQU07UUFDOUIsSUFBSUEsV0FBVyxLQUFLO1lBQ2xCZSxXQUFXO2dCQUNUdEssU0FBU3NKLFlBQVlDLFVBQVUsVUFBVSxRQUFRQTtZQUNuRDtZQUNBO1FBQ0Y7UUFDQVksZUFBZTtRQUNmLE9BQU9FLFNBQVNFLElBQUk7SUFDdEIsR0FBR0gsSUFBSSxDQUFDLENBQUN0TDtRQUNQLElBQUksT0FBT0EsU0FBUyxZQUFZQSxTQUFTLE1BQU07WUFDN0N3TCxXQUFXO2dCQUNULElBQUl4TCxTQUFTLEtBQUs7b0JBQ2hCa0IsU0FBUyxTQUFTbEI7Z0JBQ3BCLE9BQU87b0JBQ0xrQixTQUFTLFFBQVFtSztnQkFDbkI7WUFDRjtZQUNBO1FBQ0Y7UUFDQUcsV0FBVztZQUNUdEssU0FBUyxXQUFXbEI7UUFDdEI7SUFDRixHQUFHMEwsS0FBSyxDQUFDO1FBQ1B4SyxTQUFTLFFBQVFtSztJQUNuQjtBQUNGO0FBQ0EsTUFBTU0saUJBQWlCO0lBQ3JCakI7SUFDQUs7QUFDRjtBQUVBLFNBQVNhLFVBQVUxTCxLQUFLO0lBQ3RCLE1BQU1SLFNBQVM7UUFDYm1NLFFBQVEsRUFBRTtRQUNWOUksU0FBUyxFQUFFO1FBQ1grSSxTQUFTLEVBQUU7SUFDYjtJQUNBLE1BQU0xSSxVQUFVLGFBQWEsR0FBRzNFLE9BQU8yQixNQUFNLENBQUM7SUFDOUNGLE1BQU02TCxJQUFJLENBQUMsQ0FBQ0MsR0FBR0M7UUFDYixJQUFJRCxFQUFFeEssUUFBUSxLQUFLeUssRUFBRXpLLFFBQVEsRUFBRTtZQUM3QixPQUFPd0ssRUFBRXhLLFFBQVEsQ0FBQzBLLGFBQWEsQ0FBQ0QsRUFBRXpLLFFBQVE7UUFDNUM7UUFDQSxJQUFJd0ssRUFBRWxLLE1BQU0sS0FBS21LLEVBQUVuSyxNQUFNLEVBQUU7WUFDekIsT0FBT2tLLEVBQUVsSyxNQUFNLENBQUNvSyxhQUFhLENBQUNELEVBQUVuSyxNQUFNO1FBQ3hDO1FBQ0EsT0FBT2tLLEVBQUV6TCxJQUFJLENBQUMyTCxhQUFhLENBQUNELEVBQUUxTCxJQUFJO0lBQ3BDO0lBQ0EsSUFBSTRMLFdBQVc7UUFDYjNLLFVBQVU7UUFDVk0sUUFBUTtRQUNSdkIsTUFBTTtJQUNSO0lBQ0FMLE1BQU1TLE9BQU8sQ0FBQyxDQUFDb0I7UUFDYixJQUFJb0ssU0FBUzVMLElBQUksS0FBS3dCLEtBQUt4QixJQUFJLElBQUk0TCxTQUFTckssTUFBTSxLQUFLQyxLQUFLRCxNQUFNLElBQUlxSyxTQUFTM0ssUUFBUSxLQUFLTyxLQUFLUCxRQUFRLEVBQUU7WUFDekc7UUFDRjtRQUNBMkssV0FBV3BLO1FBQ1gsTUFBTVAsV0FBV08sS0FBS1AsUUFBUTtRQUM5QixNQUFNTSxTQUFTQyxLQUFLRCxNQUFNO1FBQzFCLE1BQU12QixPQUFPd0IsS0FBS3hCLElBQUk7UUFDdEIsTUFBTTJDLGtCQUFrQkUsT0FBTyxDQUFDNUIsU0FBUyxJQUFLNEIsQ0FBQUEsT0FBTyxDQUFDNUIsU0FBUyxHQUFHLGFBQWEsR0FBRy9DLE9BQU8yQixNQUFNLENBQUMsS0FBSTtRQUNwRyxNQUFNZ00sZUFBZWxKLGVBQWUsQ0FBQ3BCLE9BQU8sSUFBS29CLENBQUFBLGVBQWUsQ0FBQ3BCLE9BQU8sR0FBR21CLFdBQVd6QixVQUFVTSxPQUFNO1FBQ3RHLElBQUl1SztRQUNKLElBQUk5TCxRQUFRNkwsYUFBYWxNLEtBQUssRUFBRTtZQUM5Qm1NLE9BQU8zTSxPQUFPbU0sTUFBTTtRQUN0QixPQUFPLElBQUkvSixXQUFXLE1BQU1zSyxhQUFhckosT0FBTyxDQUFDcUIsR0FBRyxDQUFDN0QsT0FBTztZQUMxRDhMLE9BQU8zTSxPQUFPcUQsT0FBTztRQUN2QixPQUFPO1lBQ0xzSixPQUFPM00sT0FBT29NLE9BQU87UUFDdkI7UUFDQSxNQUFNeEssT0FBTztZQUNYRTtZQUNBTTtZQUNBdkI7UUFDRjtRQUNBOEwsS0FBS2hMLElBQUksQ0FBQ0M7SUFDWjtJQUNBLE9BQU81QjtBQUNUO0FBRUEsU0FBUzRNLGVBQWVDLFFBQVEsRUFBRWhFLEVBQUU7SUFDbENnRSxTQUFTNUwsT0FBTyxDQUFDLENBQUN5QztRQUNoQixNQUFNb0osUUFBUXBKLFFBQVFxSixlQUFlO1FBQ3JDLElBQUlELE9BQU87WUFDVHBKLFFBQVFxSixlQUFlLEdBQUdELE1BQU1FLE1BQU0sQ0FBQyxDQUFDQyxNQUFRQSxJQUFJcEUsRUFBRSxLQUFLQTtRQUM3RDtJQUNGO0FBQ0Y7QUFDQSxTQUFTcUUsZ0JBQWdCeEosT0FBTztJQUM5QixJQUFJLENBQUNBLFFBQVF5SixvQkFBb0IsRUFBRTtRQUNqQ3pKLFFBQVF5SixvQkFBb0IsR0FBRztRQUMvQnJCLFdBQVc7WUFDVHBJLFFBQVF5SixvQkFBb0IsR0FBRztZQUMvQixNQUFNTCxRQUFRcEosUUFBUXFKLGVBQWUsR0FBR3JKLFFBQVFxSixlQUFlLENBQUNuSyxLQUFLLENBQUMsS0FBSyxFQUFFO1lBQzdFLElBQUksQ0FBQ2tLLE1BQU1qSyxNQUFNLEVBQUU7Z0JBQ2pCO1lBQ0Y7WUFDQSxJQUFJdUssYUFBYTtZQUNqQixNQUFNdEwsV0FBVzRCLFFBQVE1QixRQUFRO1lBQ2pDLE1BQU1NLFNBQVNzQixRQUFRdEIsTUFBTTtZQUM3QjBLLE1BQU03TCxPQUFPLENBQUMsQ0FBQ1c7Z0JBQ2IsTUFBTXBCLFFBQVFvQixLQUFLcEIsS0FBSztnQkFDeEIsTUFBTTZNLFlBQVk3TSxNQUFNNEwsT0FBTyxDQUFDdkosTUFBTTtnQkFDdENyQyxNQUFNNEwsT0FBTyxHQUFHNUwsTUFBTTRMLE9BQU8sQ0FBQ1ksTUFBTSxDQUFDLENBQUMzSztvQkFDcEMsSUFBSUEsS0FBS0QsTUFBTSxLQUFLQSxRQUFRO3dCQUMxQixPQUFPO29CQUNUO29CQUNBLE1BQU12QixPQUFPd0IsS0FBS3hCLElBQUk7b0JBQ3RCLElBQUk2QyxRQUFRbEQsS0FBSyxDQUFDSyxLQUFLLEVBQUU7d0JBQ3ZCTCxNQUFNMkwsTUFBTSxDQUFDeEssSUFBSSxDQUFDOzRCQUNoQkc7NEJBQ0FNOzRCQUNBdkI7d0JBQ0Y7b0JBQ0YsT0FBTyxJQUFJNkMsUUFBUUwsT0FBTyxDQUFDcUIsR0FBRyxDQUFDN0QsT0FBTzt3QkFDcENMLE1BQU02QyxPQUFPLENBQUMxQixJQUFJLENBQUM7NEJBQ2pCRzs0QkFDQU07NEJBQ0F2Qjt3QkFDRjtvQkFDRixPQUFPO3dCQUNMdU0sYUFBYTt3QkFDYixPQUFPO29CQUNUO29CQUNBLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSTVNLE1BQU00TCxPQUFPLENBQUN2SixNQUFNLEtBQUt3SyxXQUFXO29CQUN0QyxJQUFJLENBQUNELFlBQVk7d0JBQ2ZSLGVBQWU7NEJBQUNsSjt5QkFBUSxFQUFFOUIsS0FBS2lILEVBQUU7b0JBQ25DO29CQUNBakgsS0FBS0osUUFBUSxDQUNYaEIsTUFBTTJMLE1BQU0sQ0FBQ3ZKLEtBQUssQ0FBQyxJQUNuQnBDLE1BQU02QyxPQUFPLENBQUNULEtBQUssQ0FBQyxJQUNwQnBDLE1BQU00TCxPQUFPLENBQUN4SixLQUFLLENBQUMsSUFDcEJoQixLQUFLMEwsS0FBSztnQkFFZDtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSUMsWUFBWTtBQUNoQixTQUFTQyxjQUFjaE0sUUFBUSxFQUFFaEIsS0FBSyxFQUFFaU4sY0FBYztJQUNwRCxNQUFNNUUsS0FBSzBFO0lBQ1gsTUFBTUQsUUFBUVYsZUFBZWMsSUFBSSxDQUFDLE1BQU1ELGdCQUFnQjVFO0lBQ3hELElBQUksQ0FBQ3JJLE1BQU00TCxPQUFPLENBQUN2SixNQUFNLEVBQUU7UUFDekIsT0FBT3lLO0lBQ1Q7SUFDQSxNQUFNMUwsT0FBTztRQUNYaUg7UUFDQXJJO1FBQ0FnQjtRQUNBOEw7SUFDRjtJQUNBRyxlQUFleE0sT0FBTyxDQUFDLENBQUN5QztRQUNyQkEsQ0FBQUEsUUFBUXFKLGVBQWUsSUFBS3JKLENBQUFBLFFBQVFxSixlQUFlLEdBQUcsRUFBRSxHQUFHcEwsSUFBSSxDQUFDQztJQUNuRTtJQUNBLE9BQU8wTDtBQUNUO0FBRUEsU0FBU0ssWUFBWWhCLElBQUksRUFBRW5LLFdBQVcsSUFBSSxFQUFFNkIsY0FBYyxLQUFLO0lBQzdELE1BQU1yRSxTQUFTLEVBQUU7SUFDakIyTSxLQUFLMUwsT0FBTyxDQUFDLENBQUNXO1FBQ1osTUFBTVMsT0FBTyxPQUFPVCxTQUFTLFdBQVdXLGFBQWFYLE1BQU1ZLFVBQVU2QixlQUFlekM7UUFDcEYsSUFBSVMsTUFBTTtZQUNSckMsT0FBTzJCLElBQUksQ0FBQ1U7UUFDZDtJQUNGO0lBQ0EsT0FBT3JDO0FBQ1Q7QUFFQSxnQkFBZ0I7QUFDaEIsSUFBSTROLGdCQUFnQjtJQUNsQnRFLFdBQVcsRUFBRTtJQUNiaEQsT0FBTztJQUNQbUQsU0FBUztJQUNUbkssUUFBUTtJQUNSZ0osUUFBUTtJQUNSb0Isa0JBQWtCO0FBQ3BCO0FBRUEsZUFBZTtBQUNmLFNBQVNtRSxVQUFVN0QsTUFBTSxFQUFFOEQsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLElBQUk7SUFDN0MsTUFBTUMsaUJBQWlCakUsT0FBT1YsU0FBUyxDQUFDekcsTUFBTTtJQUM5QyxNQUFNcUwsYUFBYWxFLE9BQU8xQixNQUFNLEdBQUc5QyxLQUFLaUMsS0FBSyxDQUFDakMsS0FBSzhDLE1BQU0sS0FBSzJGLGtCQUFrQmpFLE9BQU8xRCxLQUFLO0lBQzVGLElBQUlnRDtJQUNKLElBQUlVLE9BQU8xQixNQUFNLEVBQUU7UUFDakIsSUFBSXFFLE9BQU8zQyxPQUFPVixTQUFTLENBQUMxRyxLQUFLLENBQUM7UUFDbEMwRyxZQUFZLEVBQUU7UUFDZCxNQUFPcUQsS0FBSzlKLE1BQU0sR0FBRyxFQUFHO1lBQ3RCLE1BQU1zTCxZQUFZM0ksS0FBS2lDLEtBQUssQ0FBQ2pDLEtBQUs4QyxNQUFNLEtBQUtxRSxLQUFLOUosTUFBTTtZQUN4RHlHLFVBQVUzSCxJQUFJLENBQUNnTCxJQUFJLENBQUN3QixVQUFVO1lBQzlCeEIsT0FBT0EsS0FBSy9KLEtBQUssQ0FBQyxHQUFHdUwsV0FBV3BOLE1BQU0sQ0FBQzRMLEtBQUsvSixLQUFLLENBQUN1TCxZQUFZO1FBQ2hFO1FBQ0E3RSxZQUFZQSxVQUFVdkksTUFBTSxDQUFDNEw7SUFDL0IsT0FBTztRQUNMckQsWUFBWVUsT0FBT1YsU0FBUyxDQUFDMUcsS0FBSyxDQUFDc0wsWUFBWW5OLE1BQU0sQ0FBQ2lKLE9BQU9WLFNBQVMsQ0FBQzFHLEtBQUssQ0FBQyxHQUFHc0w7SUFDbEY7SUFDQSxNQUFNRSxZQUFZaEcsS0FBS0MsR0FBRztJQUMxQixJQUFJMEMsU0FBUztJQUNiLElBQUlzRCxjQUFjO0lBQ2xCLElBQUlDO0lBQ0osSUFBSUMsUUFBUTtJQUNaLElBQUlDLFFBQVEsRUFBRTtJQUNkLElBQUlDLGdCQUFnQixFQUFFO0lBQ3RCLElBQUksT0FBT1QsU0FBUyxZQUFZO1FBQzlCUyxjQUFjOU0sSUFBSSxDQUFDcU07SUFDckI7SUFDQSxTQUFTVTtRQUNQLElBQUlILE9BQU87WUFDVEksYUFBYUo7WUFDYkEsUUFBUTtRQUNWO0lBQ0Y7SUFDQSxTQUFTakI7UUFDUCxJQUFJdkMsV0FBVyxXQUFXO1lBQ3hCQSxTQUFTO1FBQ1g7UUFDQTJEO1FBQ0FGLE1BQU12TixPQUFPLENBQUMsQ0FBQ1c7WUFDYixJQUFJQSxLQUFLbUosTUFBTSxLQUFLLFdBQVc7Z0JBQzdCbkosS0FBS21KLE1BQU0sR0FBRztZQUNoQjtRQUNGO1FBQ0F5RCxRQUFRLEVBQUU7SUFDWjtJQUNBLFNBQVNJLFVBQVVwTixRQUFRLEVBQUVxTixTQUFTO1FBQ3BDLElBQUlBLFdBQVc7WUFDYkosZ0JBQWdCLEVBQUU7UUFDcEI7UUFDQSxJQUFJLE9BQU9qTixhQUFhLFlBQVk7WUFDbENpTixjQUFjOU0sSUFBSSxDQUFDSDtRQUNyQjtJQUNGO0lBQ0EsU0FBU3NOO1FBQ1AsT0FBTztZQUNMVjtZQUNBTjtZQUNBL0M7WUFDQXNEO1lBQ0FVLGdCQUFnQlAsTUFBTTNMLE1BQU07WUFDNUIrTDtZQUNBdEI7UUFDRjtJQUNGO0lBQ0EsU0FBUzBCO1FBQ1BqRSxTQUFTO1FBQ1QwRCxjQUFjeE4sT0FBTyxDQUFDLENBQUNPO1lBQ3JCQSxTQUFTLEtBQUssR0FBRzhNO1FBQ25CO0lBQ0Y7SUFDQSxTQUFTVztRQUNQVCxNQUFNdk4sT0FBTyxDQUFDLENBQUNXO1lBQ2IsSUFBSUEsS0FBS21KLE1BQU0sS0FBSyxXQUFXO2dCQUM3Qm5KLEtBQUttSixNQUFNLEdBQUc7WUFDaEI7UUFDRjtRQUNBeUQsUUFBUSxFQUFFO0lBQ1o7SUFDQSxTQUFTVSxlQUFldE4sSUFBSSxFQUFFaUssUUFBUSxFQUFFdkwsSUFBSTtRQUMxQyxNQUFNNk8sVUFBVXRELGFBQWE7UUFDN0IyQyxRQUFRQSxNQUFNeEIsTUFBTSxDQUFDLENBQUNvQyxTQUFXQSxXQUFXeE47UUFDNUMsT0FBUW1KO1lBQ04sS0FBSztnQkFDSDtZQUNGLEtBQUs7Z0JBQ0gsSUFBSW9FLFdBQVcsQ0FBQ25GLE9BQU9OLGdCQUFnQixFQUFFO29CQUN2QztnQkFDRjtnQkFDQTtZQUNGO2dCQUNFO1FBQ0o7UUFDQSxJQUFJbUMsYUFBYSxTQUFTO1lBQ3hCeUMsWUFBWWhPO1lBQ1owTztZQUNBO1FBQ0Y7UUFDQSxJQUFJRyxTQUFTO1lBQ1hiLFlBQVloTztZQUNaLElBQUksQ0FBQ2tPLE1BQU0zTCxNQUFNLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQ3lHLFVBQVV6RyxNQUFNLEVBQUU7b0JBQ3JCbU07Z0JBQ0YsT0FBTztvQkFDTEs7Z0JBQ0Y7WUFDRjtZQUNBO1FBQ0Y7UUFDQVg7UUFDQU87UUFDQSxJQUFJLENBQUNqRixPQUFPMUIsTUFBTSxFQUFFO1lBQ2xCLE1BQU1oQyxRQUFRMEQsT0FBT1YsU0FBUyxDQUFDL0MsT0FBTyxDQUFDM0UsS0FBSzBOLFFBQVE7WUFDcEQsSUFBSWhKLFVBQVUsQ0FBQyxLQUFLQSxVQUFVMEQsT0FBTzFELEtBQUssRUFBRTtnQkFDMUMwRCxPQUFPMUQsS0FBSyxHQUFHQTtZQUNqQjtRQUNGO1FBQ0F5RSxTQUFTO1FBQ1QwRCxjQUFjeE4sT0FBTyxDQUFDLENBQUNPO1lBQ3JCQSxTQUFTbEI7UUFDWDtJQUNGO0lBQ0EsU0FBUytPO1FBQ1AsSUFBSXRFLFdBQVcsV0FBVztZQUN4QjtRQUNGO1FBQ0EyRDtRQUNBLE1BQU1ZLFdBQVdoRyxVQUFVeEcsS0FBSztRQUNoQyxJQUFJd00sYUFBYSxLQUFLLEdBQUc7WUFDdkIsSUFBSWQsTUFBTTNMLE1BQU0sRUFBRTtnQkFDaEIwTCxRQUFRekMsV0FBVztvQkFDakI0QztvQkFDQSxJQUFJM0QsV0FBVyxXQUFXO3dCQUN4QmtFO3dCQUNBRDtvQkFDRjtnQkFDRixHQUFHaEYsT0FBT1AsT0FBTztnQkFDakI7WUFDRjtZQUNBdUY7WUFDQTtRQUNGO1FBQ0EsTUFBTXBOLE9BQU87WUFDWG1KLFFBQVE7WUFDUnVFO1lBQ0E5TixVQUFVLENBQUMrTixTQUFTalA7Z0JBQ2xCNE8sZUFBZXROLE1BQU0yTixTQUFTalA7WUFDaEM7UUFDRjtRQUNBa08sTUFBTTdNLElBQUksQ0FBQ0M7UUFDWHlNO1FBQ0FFLFFBQVF6QyxXQUFXdUQsVUFBVXJGLE9BQU8xSyxNQUFNO1FBQzFDeU8sTUFBTXVCLFVBQVV4QixTQUFTbE0sS0FBS0osUUFBUTtJQUN4QztJQUNBc0ssV0FBV3VEO0lBQ1gsT0FBT1A7QUFDVDtBQUVBLGVBQWU7QUFDZixTQUFTVSxlQUFlQyxHQUFHO0lBQ3pCLE1BQU16RixTQUFTO1FBQ2IsR0FBRzRELGFBQWE7UUFDaEIsR0FBRzZCLEdBQUc7SUFDUjtJQUNBLElBQUlDLFVBQVUsRUFBRTtJQUNoQixTQUFTQztRQUNQRCxVQUFVQSxRQUFRMUMsTUFBTSxDQUFDLENBQUNwTCxPQUFTQSxPQUFPbUosTUFBTSxLQUFLO0lBQ3ZEO0lBQ0EsU0FBU2dELE1BQU1ELE9BQU8sRUFBRThCLGFBQWEsRUFBRUMsWUFBWTtRQUNqRCxNQUFNQyxTQUFTakMsVUFDYjdELFFBQ0E4RCxTQUNBOEIsZUFDQSxDQUFDdFAsTUFBTXlQO1lBQ0xKO1lBQ0EsSUFBSUUsY0FBYztnQkFDaEJBLGFBQWF2UCxNQUFNeVA7WUFDckI7UUFDRjtRQUVGTCxRQUFRL04sSUFBSSxDQUFDbU87UUFDYixPQUFPQTtJQUNUO0lBQ0EsU0FBU0UsS0FBS3hPLFFBQVE7UUFDcEIsT0FBT2tPLFFBQVFNLElBQUksQ0FBQyxDQUFDbFA7WUFDbkIsT0FBT1UsU0FBU1Y7UUFDbEIsTUFBTTtJQUNSO0lBQ0EsTUFBTW1QLFdBQVc7UUFDZmxDO1FBQ0FpQztRQUNBRSxVQUFVLENBQUM1SjtZQUNUMEQsT0FBTzFELEtBQUssR0FBR0E7UUFDakI7UUFDQTZKLFVBQVUsSUFBTW5HLE9BQU8xRCxLQUFLO1FBQzVCcUo7SUFDRjtJQUNBLE9BQU9NO0FBQ1Q7QUFFQSxTQUFTRyxtQkFDVDtBQUNBLE1BQU1DLGtCQUFrQixhQUFhLEdBQUd0UixPQUFPMkIsTUFBTSxDQUFDO0FBQ3RELFNBQVM0UCxtQkFBbUJ4TyxRQUFRO0lBQ2xDLElBQUksQ0FBQ3VPLGVBQWUsQ0FBQ3ZPLFNBQVMsRUFBRTtRQUM5QixNQUFNa0ksU0FBU0MsYUFBYW5JO1FBQzVCLElBQUksQ0FBQ2tJLFFBQVE7WUFDWDtRQUNGO1FBQ0EsTUFBTXVHLGFBQWFmLGVBQWV4RjtRQUNsQyxNQUFNd0csa0JBQWtCO1lBQ3RCeEc7WUFDQXVHO1FBQ0Y7UUFDQUYsZUFBZSxDQUFDdk8sU0FBUyxHQUFHME87SUFDOUI7SUFDQSxPQUFPSCxlQUFlLENBQUN2TyxTQUFTO0FBQ2xDO0FBQ0EsU0FBUzJPLGFBQWFDLE1BQU0sRUFBRTNDLEtBQUssRUFBRXZNLFFBQVE7SUFDM0MsSUFBSStPO0lBQ0osSUFBSWxGO0lBQ0osSUFBSSxPQUFPcUYsV0FBVyxVQUFVO1FBQzlCLE1BQU1DLE1BQU14SCxhQUFhdUg7UUFDekIsSUFBSSxDQUFDQyxLQUFLO1lBQ1JuUCxTQUFTLEtBQUssR0FBRztZQUNqQixPQUFPNE87UUFDVDtRQUNBL0UsT0FBT3NGLElBQUl0RixJQUFJO1FBQ2YsTUFBTXVGLFNBQVNOLG1CQUFtQkk7UUFDbEMsSUFBSUUsUUFBUTtZQUNWTCxhQUFhSyxPQUFPTCxVQUFVO1FBQ2hDO0lBQ0YsT0FBTztRQUNMLE1BQU12RyxTQUFTWixnQkFBZ0JzSDtRQUMvQixJQUFJMUcsUUFBUTtZQUNWdUcsYUFBYWYsZUFBZXhGO1lBQzVCLE1BQU02RyxZQUFZSCxPQUFPcEgsU0FBUyxHQUFHb0gsT0FBT3BILFNBQVMsQ0FBQyxFQUFFLEdBQUc7WUFDM0QsTUFBTXFILE1BQU14SCxhQUFhMEg7WUFDekIsSUFBSUYsS0FBSztnQkFDUHRGLE9BQU9zRixJQUFJdEYsSUFBSTtZQUNqQjtRQUNGO0lBQ0Y7SUFDQSxJQUFJLENBQUNrRixjQUFjLENBQUNsRixNQUFNO1FBQ3hCN0osU0FBUyxLQUFLLEdBQUc7UUFDakIsT0FBTzRPO0lBQ1Q7SUFDQSxPQUFPRyxXQUFXeEMsS0FBSyxDQUFDQSxPQUFPMUMsTUFBTTdKLFlBQVk4TCxLQUFLO0FBQ3hEO0FBRUEsU0FBU3dELGlCQUNUO0FBQ0EsU0FBU0MsZUFBZXJOLE9BQU87SUFDN0IsSUFBSSxDQUFDQSxRQUFRc04sZUFBZSxFQUFFO1FBQzVCdE4sUUFBUXNOLGVBQWUsR0FBRztRQUMxQmxGLFdBQVc7WUFDVHBJLFFBQVFzTixlQUFlLEdBQUc7WUFDMUI5RCxnQkFBZ0J4SjtRQUNsQjtJQUNGO0FBQ0Y7QUFDQSxTQUFTdU4scUJBQXFCelEsS0FBSztJQUNqQyxNQUFNMFEsUUFBUSxFQUFFO0lBQ2hCLE1BQU1DLFVBQVUsRUFBRTtJQUNsQjNRLE1BQU1TLE9BQU8sQ0FBQyxDQUFDSjtRQUNaQSxDQUFBQSxLQUFLNkgsS0FBSyxDQUFDcEcsaUJBQWlCNE8sUUFBUUMsT0FBTSxFQUFHeFAsSUFBSSxDQUFDZDtJQUNyRDtJQUNBLE9BQU87UUFDTHFRO1FBQ0FDO0lBQ0Y7QUFDRjtBQUNBLFNBQVNDLG9CQUFvQjFOLE9BQU8sRUFBRWxELEtBQUssRUFBRUYsSUFBSTtJQUMvQyxTQUFTK1E7UUFDUCxNQUFNakYsVUFBVTFJLFFBQVE0TixZQUFZO1FBQ3BDOVEsTUFBTVMsT0FBTyxDQUFDLENBQUNKO1lBQ2IsSUFBSXVMLFNBQVM7Z0JBQ1hBLFFBQVFtRixNQUFNLENBQUMxUTtZQUNqQjtZQUNBLElBQUksQ0FBQzZDLFFBQVFsRCxLQUFLLENBQUNLLEtBQUssRUFBRTtnQkFDeEI2QyxRQUFRTCxPQUFPLENBQUNNLEdBQUcsQ0FBQzlDO1lBQ3RCO1FBQ0Y7SUFDRjtJQUNBLElBQUlQLFFBQVEsT0FBT0EsU0FBUyxVQUFVO1FBQ3BDLElBQUk7WUFDRixNQUFNa1IsU0FBUy9OLFdBQVdDLFNBQVNwRDtZQUNuQyxJQUFJLENBQUNrUixPQUFPM08sTUFBTSxFQUFFO2dCQUNsQndPO2dCQUNBO1lBQ0Y7UUFDRixFQUFFLE9BQU94TixLQUFLO1lBQ1o0TixRQUFRMUIsS0FBSyxDQUFDbE07UUFDaEI7SUFDRjtJQUNBd047SUFDQU4sZUFBZXJOO0FBQ2pCO0FBQ0EsU0FBU2dPLDJCQUEyQjdGLFFBQVEsRUFBRXJLLFFBQVE7SUFDcEQsSUFBSXFLLG9CQUFvQjhGLFNBQVM7UUFDL0I5RixTQUFTRCxJQUFJLENBQUMsQ0FBQ3RMO1lBQ2JrQixTQUFTbEI7UUFDWCxHQUFHMEwsS0FBSyxDQUFDO1lBQ1B4SyxTQUFTO1FBQ1g7SUFDRixPQUFPO1FBQ0xBLFNBQVNxSztJQUNYO0FBQ0Y7QUFDQSxTQUFTK0YsYUFBYWxPLE9BQU8sRUFBRWxELEtBQUs7SUFDbEMsSUFBSSxDQUFDa0QsUUFBUW1PLFdBQVcsRUFBRTtRQUN4Qm5PLFFBQVFtTyxXQUFXLEdBQUdyUjtJQUN4QixPQUFPO1FBQ0xrRCxRQUFRbU8sV0FBVyxHQUFHbk8sUUFBUW1PLFdBQVcsQ0FBQzlRLE1BQU0sQ0FBQ1AsT0FBTzZMLElBQUk7SUFDOUQ7SUFDQSxJQUFJLENBQUMzSSxRQUFRb08sY0FBYyxFQUFFO1FBQzNCcE8sUUFBUW9PLGNBQWMsR0FBRztRQUN6QmhHLFdBQVc7WUFDVHBJLFFBQVFvTyxjQUFjLEdBQUc7WUFDekIsTUFBTSxFQUFFaFEsUUFBUSxFQUFFTSxNQUFNLEVBQUUsR0FBR3NCO1lBQzdCLE1BQU1xTyxTQUFTck8sUUFBUW1PLFdBQVc7WUFDbEMsT0FBT25PLFFBQVFtTyxXQUFXO1lBQzFCLElBQUksQ0FBQ0UsVUFBVSxDQUFDQSxPQUFPbFAsTUFBTSxFQUFFO2dCQUM3QjtZQUNGO1lBQ0EsTUFBTW1QLG1CQUFtQnRPLFFBQVF1TyxRQUFRO1lBQ3pDLElBQUl2TyxRQUFRd08sU0FBUyxJQUFLSCxDQUFBQSxPQUFPbFAsTUFBTSxHQUFHLEtBQUssQ0FBQ21QLGdCQUFlLEdBQUk7Z0JBQ2pFTiwyQkFDRWhPLFFBQVF3TyxTQUFTLENBQUNILFFBQVEzUCxRQUFRTixXQUNsQyxDQUFDeEI7b0JBQ0M4USxvQkFBb0IxTixTQUFTcU8sUUFBUXpSO2dCQUN2QztnQkFFRjtZQUNGO1lBQ0EsSUFBSTBSLGtCQUFrQjtnQkFDcEJELE9BQU85USxPQUFPLENBQUMsQ0FBQ0o7b0JBQ2QsTUFBTWdMLFdBQVdtRyxpQkFBaUJuUixNQUFNdUIsUUFBUU47b0JBQ2hENFAsMkJBQTJCN0YsVUFBVSxDQUFDdkw7d0JBQ3BDLE1BQU02UixVQUFVN1IsT0FBTzs0QkFDckI4Qjs0QkFDQTVCLE9BQU87Z0NBQ0wsQ0FBQ0ssS0FBSyxFQUFFUDs0QkFDVjt3QkFDRixJQUFJO3dCQUNKOFEsb0JBQW9CMU4sU0FBUzs0QkFBQzdDO3lCQUFLLEVBQUVzUjtvQkFDdkM7Z0JBQ0Y7Z0JBQ0E7WUFDRjtZQUNBLE1BQU0sRUFBRWpCLEtBQUssRUFBRUMsT0FBTyxFQUFFLEdBQUdGLHFCQUFxQmM7WUFDaEQsSUFBSVosUUFBUXRPLE1BQU0sRUFBRTtnQkFDbEJ1TyxvQkFBb0IxTixTQUFTeU4sU0FBUztZQUN4QztZQUNBLElBQUksQ0FBQ0QsTUFBTXJPLE1BQU0sRUFBRTtnQkFDakI7WUFDRjtZQUNBLE1BQU04TixNQUFNdk8sT0FBT3NHLEtBQUssQ0FBQ3BHLGlCQUFpQjZHLGFBQWFySCxZQUFZO1lBQ25FLElBQUksQ0FBQzZPLEtBQUs7Z0JBQ1JTLG9CQUFvQjFOLFNBQVN3TixPQUFPO2dCQUNwQztZQUNGO1lBQ0EsTUFBTTVGLFNBQVNxRixJQUFJM0YsT0FBTyxDQUFDbEosVUFBVU0sUUFBUThPO1lBQzdDNUYsT0FBT3JLLE9BQU8sQ0FBQyxDQUFDVztnQkFDZDZPLGFBQWEzTyxVQUFVRixNQUFNLENBQUN0QjtvQkFDNUI4USxvQkFBb0IxTixTQUFTOUIsS0FBS3BCLEtBQUssRUFBRUY7Z0JBQzNDO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxNQUFNNFIsWUFBWSxDQUFDMVIsT0FBT2dCO0lBQ3hCLE1BQU00USxlQUFlekUsWUFBWW5OLE9BQU8sTUFBTThEO0lBQzlDLE1BQU0rTixjQUFjbkcsVUFBVWtHO0lBQzlCLElBQUksQ0FBQ0MsWUFBWWpHLE9BQU8sQ0FBQ3ZKLE1BQU0sRUFBRTtRQUMvQixJQUFJeVAsZUFBZTtRQUNuQixJQUFJOVEsVUFBVTtZQUNac0ssV0FBVztnQkFDVCxJQUFJd0csY0FBYztvQkFDaEI5USxTQUNFNlEsWUFBWWxHLE1BQU0sRUFDbEJrRyxZQUFZaFAsT0FBTyxFQUNuQmdQLFlBQVlqRyxPQUFPLEVBQ25CMEU7Z0JBRUo7WUFDRjtRQUNGO1FBQ0EsT0FBTztZQUNMd0IsZUFBZTtRQUNqQjtJQUNGO0lBQ0EsTUFBTUMsV0FBVyxhQUFhLEdBQUd4VCxPQUFPMkIsTUFBTSxDQUFDO0lBQy9DLE1BQU04UixVQUFVLEVBQUU7SUFDbEIsSUFBSUMsY0FBY0M7SUFDbEJMLFlBQVlqRyxPQUFPLENBQUNuTCxPQUFPLENBQUMsQ0FBQ29CO1FBQzNCLE1BQU0sRUFBRVAsUUFBUSxFQUFFTSxNQUFNLEVBQUUsR0FBR0M7UUFDN0IsSUFBSUQsV0FBV3NRLGNBQWM1USxhQUFhMlEsY0FBYztZQUN0RDtRQUNGO1FBQ0FBLGVBQWUzUTtRQUNmNFEsYUFBYXRRO1FBQ2JvUSxRQUFRN1EsSUFBSSxDQUFDNEIsV0FBV3pCLFVBQVVNO1FBQ2xDLE1BQU11USxtQkFBbUJKLFFBQVEsQ0FBQ3pRLFNBQVMsSUFBS3lRLENBQUFBLFFBQVEsQ0FBQ3pRLFNBQVMsR0FBRyxhQUFhLEdBQUcvQyxPQUFPMkIsTUFBTSxDQUFDLEtBQUk7UUFDdkcsSUFBSSxDQUFDaVMsZ0JBQWdCLENBQUN2USxPQUFPLEVBQUU7WUFDN0J1USxnQkFBZ0IsQ0FBQ3ZRLE9BQU8sR0FBRyxFQUFFO1FBQy9CO0lBQ0Y7SUFDQWlRLFlBQVlqRyxPQUFPLENBQUNuTCxPQUFPLENBQUMsQ0FBQ29CO1FBQzNCLE1BQU0sRUFBRVAsUUFBUSxFQUFFTSxNQUFNLEVBQUV2QixJQUFJLEVBQUUsR0FBR3dCO1FBQ25DLE1BQU1xQixVQUFVSCxXQUFXekIsVUFBVU07UUFDckMsTUFBTXdRLGVBQWVsUCxRQUFRNE4sWUFBWSxJQUFLNU4sQ0FBQUEsUUFBUTROLFlBQVksR0FBRyxhQUFhLEdBQUcsSUFBSWhPLEtBQUk7UUFDN0YsSUFBSSxDQUFDc1AsYUFBYWxPLEdBQUcsQ0FBQzdELE9BQU87WUFDM0IrUixhQUFhalAsR0FBRyxDQUFDOUM7WUFDakIwUixRQUFRLENBQUN6USxTQUFTLENBQUNNLE9BQU8sQ0FBQ1QsSUFBSSxDQUFDZDtRQUNsQztJQUNGO0lBQ0EyUixRQUFRdlIsT0FBTyxDQUFDLENBQUN5QztRQUNmLE1BQU1pSixPQUFPNEYsUUFBUSxDQUFDN08sUUFBUTVCLFFBQVEsQ0FBQyxDQUFDNEIsUUFBUXRCLE1BQU0sQ0FBQztRQUN2RCxJQUFJdUssS0FBSzlKLE1BQU0sRUFBRTtZQUNmK08sYUFBYWxPLFNBQVNpSjtRQUN4QjtJQUNGO0lBQ0EsT0FBT25MLFdBQVdnTSxjQUFjaE0sVUFBVTZRLGFBQWFHLFdBQVcxQjtBQUNwRTtBQUNBLE1BQU1tQixXQUFXLENBQUM1UDtJQUNoQixPQUFPLElBQUlzUCxRQUFRLENBQUNrQixTQUFTQztRQUMzQixNQUFNQyxVQUFVLE9BQU8xUSxTQUFTLFdBQVdFLGFBQWFGLE1BQU0sUUFBUUE7UUFDdEUsSUFBSSxDQUFDMFEsU0FBUztZQUNaRCxPQUFPelE7WUFDUDtRQUNGO1FBQ0E2UCxVQUFVO1lBQUNhLFdBQVcxUTtTQUFLLEVBQUUsQ0FBQzhKO1lBQzVCLElBQUlBLE9BQU90SixNQUFNLElBQUlrUSxTQUFTO2dCQUM1QixNQUFNelMsT0FBT2tFLFlBQVl1TztnQkFDekIsSUFBSXpTLE1BQU07b0JBQ1J1UyxRQUFRO3dCQUNOLEdBQUdwVCxnQkFBZ0I7d0JBQ25CLEdBQUdhLElBQUk7b0JBQ1Q7b0JBQ0E7Z0JBQ0Y7WUFDRjtZQUNBd1MsT0FBT3pRO1FBQ1Q7SUFDRjtBQUNGO0FBRUEsU0FBUzJRLHFCQUFxQkMsTUFBTSxFQUFFN1EsTUFBTSxFQUFFTixRQUFRO0lBQ3BEeUIsV0FBV3pCLFlBQVksSUFBSU0sUUFBUThQLFNBQVMsR0FBR2U7QUFDakQ7QUFDQSxTQUFTQyxvQkFBb0JELE1BQU0sRUFBRTdRLE1BQU0sRUFBRU4sUUFBUTtJQUNuRHlCLFdBQVd6QixZQUFZLElBQUlNLFFBQVE2UCxRQUFRLEdBQUdnQjtBQUNoRDtBQUVBLFNBQVNFLG9CQUFvQm5SLFFBQVEsRUFBRUosSUFBSTtJQUN6QyxNQUFNNUIsU0FBUztRQUNiLEdBQUdnQyxRQUFRO0lBQ2I7SUFDQSxJQUFLLE1BQU01QixPQUFPd0IsS0FBTTtRQUN0QixNQUFNZCxRQUFRYyxJQUFJLENBQUN4QixJQUFJO1FBQ3ZCLE1BQU1nVCxZQUFZLE9BQU90UztRQUN6QixJQUFJVixPQUFPNEUsK0JBQStCO1lBQ3hDLElBQUlsRSxVQUFVLFFBQVFBLFNBQVVzUyxDQUFBQSxjQUFjLFlBQVlBLGNBQWMsUUFBTyxHQUFJO2dCQUNqRnBULE1BQU0sQ0FBQ0ksSUFBSSxHQUFHVTtZQUNoQjtRQUNGLE9BQU8sSUFBSXNTLGNBQWMsT0FBT3BULE1BQU0sQ0FBQ0ksSUFBSSxFQUFFO1lBQzNDSixNQUFNLENBQUNJLElBQUksR0FBR0EsUUFBUSxXQUFXVSxRQUFRLElBQUlBO1FBQy9DO0lBQ0Y7SUFDQSxPQUFPZDtBQUNUO0FBRUEsTUFBTXFULFlBQVk7QUFDbEIsU0FBU0MsZUFBZUMsTUFBTSxFQUFFQyxJQUFJO0lBQ2xDQSxLQUFLN1EsS0FBSyxDQUFDMFEsV0FBV3BTLE9BQU8sQ0FBQyxDQUFDd1M7UUFDN0IsTUFBTTNTLFFBQVEyUyxJQUFJOU0sSUFBSTtRQUN0QixPQUFRN0Y7WUFDTixLQUFLO2dCQUNIeVMsT0FBTy9ULEtBQUssR0FBRztnQkFDZjtZQUNGLEtBQUs7Z0JBQ0grVCxPQUFPaFUsS0FBSyxHQUFHO2dCQUNmO1FBQ0o7SUFDRjtBQUNGO0FBRUEsU0FBU21VLGlCQUFpQjVTLEtBQUssRUFBRTZTLGVBQWUsQ0FBQztJQUMvQyxNQUFNQyxRQUFROVMsTUFBTWtJLE9BQU8sQ0FBQyxjQUFjO0lBQzFDLFNBQVMyRyxRQUFRa0UsTUFBTTtRQUNyQixNQUFPQSxTQUFTLEVBQUc7WUFDakJBLFVBQVU7UUFDWjtRQUNBLE9BQU9BLFNBQVM7SUFDbEI7SUFDQSxJQUFJRCxVQUFVLElBQUk7UUFDaEIsTUFBTTdOLE1BQU0rTixTQUFTaFQ7UUFDckIsT0FBT21GLE1BQU1GLE9BQU8sSUFBSTRKLFFBQVE1SjtJQUNsQyxPQUFPLElBQUk2TixVQUFVOVMsT0FBTztRQUMxQixJQUFJNkIsUUFBUTtRQUNaLE9BQVFpUjtZQUNOLEtBQUs7Z0JBQ0hqUixRQUFRO2dCQUNSO1lBQ0YsS0FBSztnQkFDSEEsUUFBUTtRQUNaO1FBQ0EsSUFBSUEsT0FBTztZQUNULElBQUlvRCxNQUFNQyxXQUFXbEYsTUFBTThCLEtBQUssQ0FBQyxHQUFHOUIsTUFBTStCLE1BQU0sR0FBRytRLE1BQU0vUSxNQUFNO1lBQy9ELElBQUlvRCxNQUFNRixNQUFNO2dCQUNkLE9BQU87WUFDVDtZQUNBQSxNQUFNQSxNQUFNcEQ7WUFDWixPQUFPb0QsTUFBTSxNQUFNLElBQUk0SixRQUFRNUosT0FBTztRQUN4QztJQUNGO0lBQ0EsT0FBTzROO0FBQ1Q7QUFFQSxTQUFTSSxXQUFXcFUsSUFBSSxFQUFFb0ksVUFBVTtJQUNsQyxJQUFJaU0sb0JBQW9CclUsS0FBSzRHLE9BQU8sQ0FBQyxjQUFjLENBQUMsSUFBSSxLQUFLO0lBQzdELElBQUssTUFBTTBOLFFBQVFsTSxXQUFZO1FBQzdCaU0scUJBQXFCLE1BQU1DLE9BQU8sT0FBT2xNLFVBQVUsQ0FBQ2tNLEtBQUssR0FBRztJQUM5RDtJQUNBLE9BQU8sNENBQTRDRCxvQkFBb0IsTUFBTXJVLE9BQU87QUFDdEY7QUFFQSxTQUFTdVUsZ0JBQWdCQyxHQUFHO0lBQzFCLE9BQU9BLElBQUluTCxPQUFPLENBQUMsTUFBTSxLQUFLQSxPQUFPLENBQUMsTUFBTSxPQUFPQSxPQUFPLENBQUMsTUFBTSxPQUFPQSxPQUFPLENBQUMsTUFBTSxPQUFPQSxPQUFPLENBQUMsTUFBTSxPQUFPQSxPQUFPLENBQUMsUUFBUTtBQUNwSTtBQUNBLFNBQVNvTCxVQUFVRCxHQUFHO0lBQ3BCLE9BQU8sd0JBQXdCRCxnQkFBZ0JDO0FBQ2pEO0FBQ0EsU0FBU0UsU0FBU0YsR0FBRztJQUNuQixPQUFPLFVBQVVDLFVBQVVELE9BQU87QUFDcEM7QUFFQSxJQUFJRztBQUNKLFNBQVNDO0lBQ1AsSUFBSTtRQUNGRCxTQUFTRSxPQUFPQyxZQUFZLENBQUNGLFlBQVksQ0FBQyxXQUFXO1lBQ25ELCtEQUErRDtZQUMvREcsWUFBWSxDQUFDQyxJQUFNQTtRQUNyQjtJQUNGLEVBQUUsT0FBTzlRLEtBQUs7UUFDWnlRLFNBQVM7SUFDWDtBQUNGO0FBQ0EsU0FBU00saUJBQWlCQyxJQUFJO0lBQzVCLElBQUlQLFdBQVcsS0FBSyxHQUFHO1FBQ3JCQztJQUNGO0lBQ0EsT0FBT0QsU0FBU0EsT0FBT0ksVUFBVSxDQUFDRyxRQUFRQTtBQUM1QztBQUVBLE1BQU1DLG9DQUFvQztJQUN0QyxHQUFHN1AseUJBQXlCO0lBQzVCOFAsUUFBUTtBQUNaO0FBRUE7O0NBRUMsR0FDRCxNQUFNQyxjQUFjO0lBQ2hCLFNBQVM7SUFDVCxjQUFjO0lBQ2QsZUFBZTtJQUNmLFFBQVE7QUFDWjtBQUNBOztDQUVDLEdBQ0QsTUFBTUMsY0FBYztJQUNoQkMsU0FBUztBQUNiO0FBQ0EsTUFBTUMsZ0JBQWdCO0lBQ2xCQyxpQkFBaUI7QUFDckI7QUFDQSxNQUFNQyxlQUFlO0lBQ2pCRCxpQkFBaUI7QUFDckI7QUFDQSxrREFBa0Q7QUFDbEQsTUFBTUUsYUFBYTtJQUNmQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsTUFBTTtBQUNWO0FBQ0EsTUFBTUMsZUFBZTtJQUNqQkMsWUFBWVI7SUFDWlMsTUFBTVQ7SUFDTlUsWUFBWVI7QUFDaEI7QUFDQSxJQUFLLE1BQU1qVCxVQUFVc1QsYUFBYztJQUMvQixNQUFNL0ksT0FBTytJLFlBQVksQ0FBQ3RULE9BQU87SUFDakMsSUFBSyxNQUFNSCxRQUFRcVQsV0FBWTtRQUMzQjNJLElBQUksQ0FBQ3ZLLFNBQVNILEtBQUssR0FBR3FULFVBQVUsQ0FBQ3JULEtBQUs7SUFDMUM7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTZULGlCQUFpQjtJQUNuQixHQUFHaEIsaUNBQWlDO0lBQ3BDQyxRQUFRO0FBQ1o7QUFDQTs7Q0FFQyxHQUNELFNBQVNnQixRQUFRalYsS0FBSztJQUNsQixPQUFPQSxRQUFTQSxDQUFBQSxNQUFNNEgsS0FBSyxDQUFDLGdCQUFnQixPQUFPLEVBQUM7QUFDeEQ7QUFDQTs7Q0FFQyxHQUNELE1BQU1zTixTQUFTLENBQ2Ysc0RBQXNEO0FBQ3REM1QsTUFDQSxxQkFBcUI7QUFDckIrRSxPQUNBLFlBQVk7QUFDWnZHO0lBQ0kseUJBQXlCO0lBQ3pCLE1BQU1vVixlQUFlN08sTUFBTTJOLE1BQU0sR0FDM0JlLGlCQUNBaEI7SUFDTix5QkFBeUI7SUFDekIsTUFBTTlOLGlCQUFpQm1NLG9CQUFvQjhDLGNBQWM3TztJQUN6RCxhQUFhO0lBQ2IsTUFBTThPLE9BQU85TyxNQUFNOE8sSUFBSSxJQUFJO0lBQzNCLGVBQWU7SUFDZixNQUFNQyxRQUFRLENBQUM7SUFDZixNQUFNQyxjQUFjaFAsTUFBTStPLEtBQUssSUFBSSxDQUFDO0lBQ3BDLGtDQUFrQztJQUNsQyxNQUFNRSxpQkFBaUI7UUFDbkIsR0FBSUgsU0FBUyxRQUFRbEIsY0FBYyxDQUFDLENBQUM7SUFDekM7SUFDQSxJQUFJblUsTUFBTTtRQUNOLE1BQU00RCxXQUFXbEMsYUFBYTFCLE1BQU0sT0FBTztRQUMzQyxJQUFJNEQsVUFBVTtZQUNWLE1BQU02UixhQUFhO2dCQUFDO2FBQVU7WUFDOUIsTUFBTWxQLFFBQVE7Z0JBQ1Y7Z0JBQ0E7YUFDSDtZQUNELEtBQUssTUFBTW5GLFFBQVFtRixNQUFPO2dCQUN0QixJQUFJM0MsUUFBUSxDQUFDeEMsS0FBSyxFQUFFO29CQUNoQnFVLFdBQVczVSxJQUFJLENBQUMsY0FBYzhDLFFBQVEsQ0FBQ3hDLEtBQUs7Z0JBQ2hEO1lBQ0o7WUFDQW9VLGVBQWVFLFNBQVMsR0FBR0QsV0FBV3BULElBQUksQ0FBQztRQUMvQztJQUNKO0lBQ0EseUJBQXlCO0lBQ3pCLElBQUssSUFBSTlDLE9BQU9nSCxNQUFPO1FBQ25CLE1BQU10RyxRQUFRc0csS0FBSyxDQUFDaEgsSUFBSTtRQUN4QixJQUFJVSxVQUFVLEtBQUssR0FBRztZQUNsQjtRQUNKO1FBQ0EsT0FBUVY7WUFDSix1QkFBdUI7WUFDdkIsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNEO1lBQ0osY0FBYztZQUNkLEtBQUs7Z0JBQ0RpVyxlQUFlRyxHQUFHLEdBQUcxVjtnQkFDckI7WUFDSixvQkFBb0I7WUFDcEIsS0FBSztnQkFDRHVWLGNBQWMsQ0FBQ2pXLElBQUksR0FDZixDQUFDaVcsY0FBYyxDQUFDalcsSUFBSSxHQUFHaVcsY0FBYyxDQUFDalcsSUFBSSxHQUFHLE1BQU0sRUFBQyxJQUNoRFU7Z0JBQ1I7WUFDSixxQkFBcUI7WUFDckIsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNEa0csY0FBYyxDQUFDNUcsSUFBSSxHQUNmVSxVQUFVLFFBQVFBLFVBQVUsVUFBVUEsVUFBVTtnQkFDcEQ7WUFDSix3Q0FBd0M7WUFDeEMsS0FBSztnQkFDRCxJQUFJLE9BQU9BLFVBQVUsVUFBVTtvQkFDM0J3UyxlQUFldE0sZ0JBQWdCbEc7Z0JBQ25DO2dCQUNBO1lBQ0osdUJBQXVCO1lBQ3ZCLEtBQUs7Z0JBQ0RxVixNQUFNTSxLQUFLLEdBQUczVjtnQkFDZDtZQUNKLHFCQUFxQjtZQUNyQixLQUFLO2dCQUNELElBQUksT0FBT0EsVUFBVSxVQUFVO29CQUMzQmtHLGNBQWMsQ0FBQzVHLElBQUksR0FBR3NULGlCQUFpQjVTO2dCQUMzQyxPQUNLLElBQUksT0FBT0EsVUFBVSxVQUFVO29CQUNoQ2tHLGNBQWMsQ0FBQzVHLElBQUksR0FBR1U7Z0JBQzFCO2dCQUNBO1lBQ0oscUJBQXFCO1lBQ3JCLEtBQUs7WUFDTCxLQUFLO2dCQUNELElBQUlBLFVBQVUsUUFBUUEsVUFBVSxRQUFRO29CQUNwQyxPQUFPdVYsY0FBYyxDQUFDLGNBQWM7Z0JBQ3hDO2dCQUNBO1lBQ0osK0RBQStEO1lBQy9EO2dCQUNJLElBQUlKLFlBQVksQ0FBQzdWLElBQUksS0FBSyxLQUFLLEdBQUc7b0JBQzlCaVcsY0FBYyxDQUFDalcsSUFBSSxHQUFHVTtnQkFDMUI7UUFDUjtJQUNKO0lBQ0EsZ0JBQWdCO0lBQ2hCLE1BQU1jLE9BQU9tRixVQUFVMUUsTUFBTTJFO0lBQzdCLE1BQU0wUCxnQkFBZ0I5VSxLQUFLbUcsVUFBVTtJQUNyQyxpQkFBaUI7SUFDakIsSUFBSWYsZUFBZStOLE1BQU0sRUFBRTtRQUN2Qm9CLE1BQU1RLGFBQWEsR0FBRztJQUMxQjtJQUNBLElBQUlULFNBQVMsT0FBTztRQUNoQixZQUFZO1FBQ1pHLGVBQWVGLEtBQUssR0FBRztZQUNuQixHQUFHQSxLQUFLO1lBQ1IsR0FBR0MsV0FBVztRQUNsQjtRQUNBLGlCQUFpQjtRQUNqQnJYLE9BQU82WCxNQUFNLENBQUNQLGdCQUFnQks7UUFDOUIsMkZBQTJGO1FBQzNGLElBQUlHLGVBQWU7UUFDbkIsSUFBSWhPLEtBQUt6QixNQUFNeUIsRUFBRTtRQUNqQixJQUFJLE9BQU9BLE9BQU8sVUFBVTtZQUN4QixtREFBbUQ7WUFDbkRBLEtBQUtBLEdBQUdHLE9BQU8sQ0FBQyxNQUFNO1FBQzFCO1FBQ0EsaUJBQWlCO1FBQ2pCcU4sZUFBZVMsdUJBQXVCLEdBQUc7WUFDckNDLFFBQVFuQyxpQkFBaUJwTSxXQUFXNUcsS0FBS2pDLElBQUksRUFBRWtKLEtBQUssSUFBTUEsS0FBSyxPQUFPZ08saUJBQWlCO1FBQzNGO1FBQ0EscUJBQU9uWSxvREFBYUEsQ0FBQyxPQUFPMlg7SUFDaEM7SUFDQSwyQkFBMkI7SUFDM0IsTUFBTSxFQUFFMVcsSUFBSSxFQUFFUixLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHaUQ7SUFDaEMsTUFBTTJVLFVBQVVkLFNBQVMsVUFDcEJBLENBQUFBLFNBQVMsT0FBTyxRQUFRdlcsS0FBSzRHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQztJQUMvRCxlQUFlO0lBQ2YsTUFBTXNPLE9BQU9kLFdBQVdwVSxNQUFNO1FBQzFCLEdBQUcrVyxhQUFhO1FBQ2hCdlgsT0FBT0EsUUFBUTtRQUNmQyxRQUFRQSxTQUFTO0lBQ3JCO0lBQ0EsaUJBQWlCO0lBQ2pCaVgsZUFBZUYsS0FBSyxHQUFHO1FBQ25CLEdBQUdBLEtBQUs7UUFDUixTQUFTOUIsU0FBU1E7UUFDbEIsU0FBU2tCLFFBQVFXLGNBQWN2WCxLQUFLO1FBQ3BDLFVBQVU0VyxRQUFRVyxjQUFjdFgsTUFBTTtRQUN0QyxHQUFHNlYsV0FBVztRQUNkLEdBQUkrQixVQUFVN0IsZ0JBQWdCRSxZQUFZO1FBQzFDLEdBQUdlLFdBQVc7SUFDbEI7SUFDQSxxQkFBTzFYLG9EQUFhQSxDQUFDLFFBQVEyWDtBQUNqQztBQUVBOztDQUVDLEdBQ0QscUJBQXFCO0FBQ3JCL1IsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjRFLGFBQWEsSUFBSStDO0FBQ2pCOztDQUVDLEdBQ0QsSUFBSSxPQUFPZ0wsYUFBYSxlQUFlLGdCQUFrQixhQUFhLEVBbURyRTtBQUNELFNBQVNNLGNBQWNuUSxLQUFLO0lBQ3hCLE1BQU0sQ0FBQ29RLFNBQVNDLFdBQVcsR0FBRzdZLCtDQUFRQSxDQUFDLENBQUMsQ0FBQ3dJLE1BQU1zUSxHQUFHO0lBQ2xELE1BQU0sQ0FBQ3BLLE9BQU9xSyxTQUFTLEdBQUcvWSwrQ0FBUUEsQ0FBQyxDQUFDO0lBQ3BDLG9CQUFvQjtJQUNwQixTQUFTZ1osZ0JBQWdCSixPQUFPO1FBQzVCLElBQUlBLFNBQVM7WUFDVCxNQUFNM1csT0FBT3VHLE1BQU0vRSxJQUFJO1lBQ3ZCLElBQUksT0FBT3hCLFNBQVMsVUFBVTtnQkFDMUIsaUJBQWlCO2dCQUNqQixPQUFPO29CQUNIQSxNQUFNO29CQUNOUCxNQUFNTztnQkFDVjtZQUNKO1lBQ0EsTUFBTVAsT0FBT2tFLFlBQVkzRDtZQUN6QixJQUFJUCxNQUFNO2dCQUNOLE9BQU87b0JBQ0hPO29CQUNBUDtnQkFDSjtZQUNKO1FBQ0o7UUFDQSxPQUFPO1lBQ0hPLE1BQU07UUFDVjtJQUNKO0lBQ0EsTUFBTSxDQUFDZ1gsT0FBT0MsU0FBUyxHQUFHbFosK0NBQVFBLENBQUNnWixnQkFBZ0IsQ0FBQyxDQUFDeFEsTUFBTXNRLEdBQUc7SUFDOUQsaUJBQWlCO0lBQ2pCLFNBQVMvSDtRQUNMLE1BQU1uTyxXQUFXOEwsTUFBTTlMLFFBQVE7UUFDL0IsSUFBSUEsVUFBVTtZQUNWQTtZQUNBbVcsU0FBUyxDQUFDO1FBQ2Q7SUFDSjtJQUNBLGtDQUFrQztJQUNsQyxTQUFTSSxZQUFZQyxRQUFRO1FBQ3pCLElBQUlDLEtBQUtDLFNBQVMsQ0FBQ0wsV0FBV0ksS0FBS0MsU0FBUyxDQUFDRixXQUFXO1lBQ3BEckk7WUFDQW1JLFNBQVNFO1lBQ1QsT0FBTztRQUNYO0lBQ0o7SUFDQSxlQUFlO0lBQ2YsU0FBU0c7UUFDTCxJQUFJQztRQUNKLE1BQU12WCxPQUFPdUcsTUFBTS9FLElBQUk7UUFDdkIsSUFBSSxPQUFPeEIsU0FBUyxVQUFVO1lBQzFCLGlCQUFpQjtZQUNqQmtYLFlBQVk7Z0JBQ1JsWCxNQUFNO2dCQUNOUCxNQUFNTztZQUNWO1lBQ0E7UUFDSjtRQUNBLDRCQUE0QjtRQUM1QixNQUFNUCxPQUFPa0UsWUFBWTNEO1FBQ3pCLElBQUlrWCxZQUFZO1lBQ1psWDtZQUNBUDtRQUNKLElBQUk7WUFDQSxJQUFJQSxTQUFTK1gsV0FBVztnQkFDcEIsb0NBQW9DO2dCQUNwQyxNQUFNN1csV0FBVzBRLFVBQVU7b0JBQUNyUjtpQkFBSyxFQUFFc1g7Z0JBQ25DUixTQUFTO29CQUNMblc7Z0JBQ0o7WUFDSixPQUNLLElBQUlsQixNQUFNO2dCQUNYLDZEQUE2RDtnQkFDNUQ4WCxDQUFBQSxLQUFLaFIsTUFBTWtSLE1BQU0sTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdHLElBQUksQ0FBQ25SLE9BQU92RztZQUM1RTtRQUNKO0lBQ0o7SUFDQSxvQ0FBb0M7SUFDcENoQyxnREFBU0E7bUNBQUM7WUFDTjRZLFdBQVc7WUFDWCxPQUFPOUg7UUFDWDtrQ0FBRyxFQUFFO0lBQ0wsb0NBQW9DO0lBQ3BDOVEsZ0RBQVNBO21DQUFDO1lBQ04sSUFBSTJZLFNBQVM7Z0JBQ1RXO1lBQ0o7UUFDSjtrQ0FBRztRQUFDL1EsTUFBTS9FLElBQUk7UUFBRW1WO0tBQVE7SUFDeEIsY0FBYztJQUNkLE1BQU0sRUFBRTNXLElBQUksRUFBRVAsSUFBSSxFQUFFLEdBQUd1WDtJQUN2QixJQUFJLENBQUN2WCxNQUFNO1FBQ1AsT0FBTzhHLE1BQU1vUixRQUFRLEdBQ2ZwUixNQUFNb1IsUUFBUSxHQUNkcFIsTUFBTXFSLFFBQVEsR0FDVnJSLE1BQU1xUixRQUFRLGlCQUNkL1osb0RBQWFBLENBQUMsUUFBUSxDQUFDO0lBQ3JDO0lBQ0EsT0FBT3NYLE9BQU87UUFDVixHQUFHdlcsZ0JBQWdCO1FBQ25CLEdBQUdhLElBQUk7SUFDWCxHQUFHOEcsT0FBT3ZHO0FBQ2Q7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTTZYLHFCQUFPL1osaURBQVVBLENBQUMsQ0FBQ3lJLE9BQU9vUCxNQUFRZSxjQUFjO1FBQ2xELEdBQUduUSxLQUFLO1FBQ1J1UixNQUFNbkM7SUFDVjtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNb0MsMkJBQWFqYSxpREFBVUEsQ0FBQyxDQUFDeUksT0FBT29QLE1BQVFlLGNBQWM7UUFDeER4QyxRQUFRO1FBQ1IsR0FBRzNOLEtBQUs7UUFDUnVSLE1BQU1uQztJQUNWO0FBQ0E7O0NBRUMsR0FDRCxNQUFNcUMsT0FBTztJQUNUNU87SUFDQWY7SUFDQXVIO0lBQ0FuRztJQUNBRTtJQUNBTjtBQUNKO0FBRTZOIiwic291cmNlcyI6WyJDOlxcZW5vY2tcXFRTXFxub2RlX21vZHVsZXNcXEBpY29uaWZ5XFxyZWFjdFxcZGlzdFxcaWNvbmlmeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGZvcndhcmRSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IGRlZmF1bHRJY29uRGltZW5zaW9ucyA9IE9iamVjdC5mcmVlemUoXG4gIHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICB3aWR0aDogMTYsXG4gICAgaGVpZ2h0OiAxNlxuICB9XG4pO1xuY29uc3QgZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgcm90YXRlOiAwLFxuICB2RmxpcDogZmFsc2UsXG4gIGhGbGlwOiBmYWxzZVxufSk7XG5jb25zdCBkZWZhdWx0SWNvblByb3BzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC4uLmRlZmF1bHRJY29uRGltZW5zaW9ucyxcbiAgLi4uZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnNcbn0pO1xuY29uc3QgZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gIGJvZHk6IFwiXCIsXG4gIGhpZGRlbjogZmFsc2Vcbn0pO1xuXG5mdW5jdGlvbiBtZXJnZUljb25UcmFuc2Zvcm1hdGlvbnMob2JqMSwgb2JqMikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgaWYgKCFvYmoxLmhGbGlwICE9PSAhb2JqMi5oRmxpcCkge1xuICAgIHJlc3VsdC5oRmxpcCA9IHRydWU7XG4gIH1cbiAgaWYgKCFvYmoxLnZGbGlwICE9PSAhb2JqMi52RmxpcCkge1xuICAgIHJlc3VsdC52RmxpcCA9IHRydWU7XG4gIH1cbiAgY29uc3Qgcm90YXRlID0gKChvYmoxLnJvdGF0ZSB8fCAwKSArIChvYmoyLnJvdGF0ZSB8fCAwKSkgJSA0O1xuICBpZiAocm90YXRlKSB7XG4gICAgcmVzdWx0LnJvdGF0ZSA9IHJvdGF0ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtZXJnZUljb25EYXRhKHBhcmVudCwgY2hpbGQpIHtcbiAgY29uc3QgcmVzdWx0ID0gbWVyZ2VJY29uVHJhbnNmb3JtYXRpb25zKHBhcmVudCwgY2hpbGQpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHMpIHtcbiAgICBpZiAoa2V5IGluIGRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zKSB7XG4gICAgICBpZiAoa2V5IGluIHBhcmVudCAmJiAhKGtleSBpbiByZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSBpbiBjaGlsZCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBjaGlsZFtrZXldO1xuICAgIH0gZWxzZSBpZiAoa2V5IGluIHBhcmVudCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBwYXJlbnRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0SWNvbnNUcmVlKGRhdGEsIG5hbWVzKSB7XG4gIGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcbiAgY29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcyB8fCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgcmVzb2x2ZWQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZnVuY3Rpb24gcmVzb2x2ZShuYW1lKSB7XG4gICAgaWYgKGljb25zW25hbWVdKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRbbmFtZV0gPSBbXTtcbiAgICB9XG4gICAgaWYgKCEobmFtZSBpbiByZXNvbHZlZCkpIHtcbiAgICAgIHJlc29sdmVkW25hbWVdID0gbnVsbDtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGFsaWFzZXNbbmFtZV0gJiYgYWxpYXNlc1tuYW1lXS5wYXJlbnQ7XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcmVudCAmJiByZXNvbHZlKHBhcmVudCk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZWRbbmFtZV0gPSBbcGFyZW50XS5jb25jYXQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRbbmFtZV07XG4gIH1cbiAgKE9iamVjdC5rZXlzKGljb25zKS5jb25jYXQoT2JqZWN0LmtleXMoYWxpYXNlcykpKS5mb3JFYWNoKHJlc29sdmUpO1xuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SWNvbkRhdGEoZGF0YSwgbmFtZSwgdHJlZSkge1xuICBjb25zdCBpY29ucyA9IGRhdGEuaWNvbnM7XG4gIGNvbnN0IGFsaWFzZXMgPSBkYXRhLmFsaWFzZXMgfHwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBjdXJyZW50UHJvcHMgPSB7fTtcbiAgZnVuY3Rpb24gcGFyc2UobmFtZTIpIHtcbiAgICBjdXJyZW50UHJvcHMgPSBtZXJnZUljb25EYXRhKFxuICAgICAgaWNvbnNbbmFtZTJdIHx8IGFsaWFzZXNbbmFtZTJdLFxuICAgICAgY3VycmVudFByb3BzXG4gICAgKTtcbiAgfVxuICBwYXJzZShuYW1lKTtcbiAgdHJlZS5mb3JFYWNoKHBhcnNlKTtcbiAgcmV0dXJuIG1lcmdlSWNvbkRhdGEoZGF0YSwgY3VycmVudFByb3BzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VJY29uU2V0KGRhdGEsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IG5hbWVzID0gW107XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZGF0YS5pY29ucyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBuYW1lcztcbiAgfVxuICBpZiAoZGF0YS5ub3RfZm91bmQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGRhdGEubm90X2ZvdW5kLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGNhbGxiYWNrKG5hbWUsIG51bGwpO1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCB0cmVlID0gZ2V0SWNvbnNUcmVlKGRhdGEpO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gdHJlZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0cmVlW25hbWVdO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjYWxsYmFjayhuYW1lLCBpbnRlcm5hbEdldEljb25EYXRhKGRhdGEsIG5hbWUsIGl0ZW0pKTtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuYW1lcztcbn1cblxuY29uc3Qgb3B0aW9uYWxQcm9wZXJ0eURlZmF1bHRzID0ge1xuICBwcm92aWRlcjogXCJcIixcbiAgYWxpYXNlczoge30sXG4gIG5vdF9mb3VuZDoge30sXG4gIC4uLmRlZmF1bHRJY29uRGltZW5zaW9uc1xufTtcbmZ1bmN0aW9uIGNoZWNrT3B0aW9uYWxQcm9wcyhpdGVtLCBkZWZhdWx0cykge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAocHJvcCBpbiBpdGVtICYmIHR5cGVvZiBpdGVtW3Byb3BdICE9PSB0eXBlb2YgZGVmYXVsdHNbcHJvcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBxdWlja2x5VmFsaWRhdGVJY29uU2V0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkYXRhID0gb2JqO1xuICBpZiAodHlwZW9mIGRhdGEucHJlZml4ICE9PSBcInN0cmluZ1wiIHx8ICFvYmouaWNvbnMgfHwgdHlwZW9mIG9iai5pY29ucyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghY2hlY2tPcHRpb25hbFByb3BzKG9iaiwgb3B0aW9uYWxQcm9wZXJ0eURlZmF1bHRzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcbiAgZm9yIChjb25zdCBuYW1lIGluIGljb25zKSB7XG4gICAgY29uc3QgaWNvbiA9IGljb25zW25hbWVdO1xuICAgIGlmIChcbiAgICAgIC8vIE5hbWUgY2Fubm90IGJlIGVtcHR5XG4gICAgICAhbmFtZSB8fCAvLyBNdXN0IGhhdmUgYm9keVxuICAgICAgdHlwZW9mIGljb24uYm9keSAhPT0gXCJzdHJpbmdcIiB8fCAvLyBDaGVjayBvdGhlciBwcm9wc1xuICAgICAgIWNoZWNrT3B0aW9uYWxQcm9wcyhcbiAgICAgICAgaWNvbixcbiAgICAgICAgZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgY29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcyB8fCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBuYW1lIGluIGFsaWFzZXMpIHtcbiAgICBjb25zdCBpY29uID0gYWxpYXNlc1tuYW1lXTtcbiAgICBjb25zdCBwYXJlbnQgPSBpY29uLnBhcmVudDtcbiAgICBpZiAoXG4gICAgICAvLyBOYW1lIGNhbm5vdCBiZSBlbXB0eVxuICAgICAgIW5hbWUgfHwgLy8gUGFyZW50IG11c3QgYmUgc2V0IGFuZCBwb2ludCB0byBleGlzdGluZyBpY29uXG4gICAgICB0eXBlb2YgcGFyZW50ICE9PSBcInN0cmluZ1wiIHx8ICFpY29uc1twYXJlbnRdICYmICFhbGlhc2VzW3BhcmVudF0gfHwgLy8gQ2hlY2sgb3RoZXIgcHJvcHNcbiAgICAgICFjaGVja09wdGlvbmFsUHJvcHMoXG4gICAgICAgIGljb24sXG4gICAgICAgIGRlZmF1bHRFeHRlbmRlZEljb25Qcm9wc1xuICAgICAgKVxuICAgICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5jb25zdCBtYXRjaEljb25OYW1lID0gL15bYS16MC05XSsoLVthLXowLTldKykqJC87XG5jb25zdCBzdHJpbmdUb0ljb24gPSAodmFsdWUsIHZhbGlkYXRlLCBhbGxvd1NpbXBsZU5hbWUsIHByb3ZpZGVyID0gXCJcIikgPT4ge1xuICBjb25zdCBjb2xvblNlcGFyYXRlZCA9IHZhbHVlLnNwbGl0KFwiOlwiKTtcbiAgaWYgKHZhbHVlLnNsaWNlKDAsIDEpID09PSBcIkBcIikge1xuICAgIGlmIChjb2xvblNlcGFyYXRlZC5sZW5ndGggPCAyIHx8IGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwcm92aWRlciA9IGNvbG9uU2VwYXJhdGVkLnNoaWZ0KCkuc2xpY2UoMSk7XG4gIH1cbiAgaWYgKGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDMgfHwgIWNvbG9uU2VwYXJhdGVkLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb2xvblNlcGFyYXRlZC5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgbmFtZTIgPSBjb2xvblNlcGFyYXRlZC5wb3AoKTtcbiAgICBjb25zdCBwcmVmaXggPSBjb2xvblNlcGFyYXRlZC5wb3AoKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAvLyBBbGxvdyBwcm92aWRlciB3aXRob3V0ICdAJzogXCJwcm92aWRlcjpwcmVmaXg6bmFtZVwiXG4gICAgICBwcm92aWRlcjogY29sb25TZXBhcmF0ZWQubGVuZ3RoID4gMCA/IGNvbG9uU2VwYXJhdGVkWzBdIDogcHJvdmlkZXIsXG4gICAgICBwcmVmaXgsXG4gICAgICBuYW1lOiBuYW1lMlxuICAgIH07XG4gICAgcmV0dXJuIHZhbGlkYXRlICYmICF2YWxpZGF0ZUljb25OYW1lKHJlc3VsdCkgPyBudWxsIDogcmVzdWx0O1xuICB9XG4gIGNvbnN0IG5hbWUgPSBjb2xvblNlcGFyYXRlZFswXTtcbiAgY29uc3QgZGFzaFNlcGFyYXRlZCA9IG5hbWUuc3BsaXQoXCItXCIpO1xuICBpZiAoZGFzaFNlcGFyYXRlZC5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcHJvdmlkZXIsXG4gICAgICBwcmVmaXg6IGRhc2hTZXBhcmF0ZWQuc2hpZnQoKSxcbiAgICAgIG5hbWU6IGRhc2hTZXBhcmF0ZWQuam9pbihcIi1cIilcbiAgICB9O1xuICAgIHJldHVybiB2YWxpZGF0ZSAmJiAhdmFsaWRhdGVJY29uTmFtZShyZXN1bHQpID8gbnVsbCA6IHJlc3VsdDtcbiAgfVxuICBpZiAoYWxsb3dTaW1wbGVOYW1lICYmIHByb3ZpZGVyID09PSBcIlwiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcHJvdmlkZXIsXG4gICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgICByZXR1cm4gdmFsaWRhdGUgJiYgIXZhbGlkYXRlSWNvbk5hbWUocmVzdWx0LCBhbGxvd1NpbXBsZU5hbWUpID8gbnVsbCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCB2YWxpZGF0ZUljb25OYW1lID0gKGljb24sIGFsbG93U2ltcGxlTmFtZSkgPT4ge1xuICBpZiAoIWljb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICEhLy8gQ2hlY2sgcHJlZml4OiBjYW5ub3QgYmUgZW1wdHksIHVubGVzcyBhbGxvd1NpbXBsZU5hbWUgaXMgZW5hYmxlZFxuICAvLyBDaGVjayBuYW1lOiBjYW5ub3QgYmUgZW1wdHlcbiAgKChhbGxvd1NpbXBsZU5hbWUgJiYgaWNvbi5wcmVmaXggPT09IFwiXCIgfHwgISFpY29uLnByZWZpeCkgJiYgISFpY29uLm5hbWUpO1xufTtcblxuY29uc3QgZGF0YVN0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIG5ld1N0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkge1xuICByZXR1cm4ge1xuICAgIHByb3ZpZGVyLFxuICAgIHByZWZpeCxcbiAgICBpY29uczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgbWlzc2luZzogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RvcmFnZSA9IGRhdGFTdG9yYWdlW3Byb3ZpZGVyXSB8fCAoZGF0YVN0b3JhZ2VbcHJvdmlkZXJdID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICByZXR1cm4gcHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gfHwgKHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID0gbmV3U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG59XG5mdW5jdGlvbiBhZGRJY29uU2V0KHN0b3JhZ2UsIGRhdGEpIHtcbiAgaWYgKCFxdWlja2x5VmFsaWRhdGVJY29uU2V0KGRhdGEpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBwYXJzZUljb25TZXQoZGF0YSwgKG5hbWUsIGljb24pID0+IHtcbiAgICBpZiAoaWNvbikge1xuICAgICAgc3RvcmFnZS5pY29uc1tuYW1lXSA9IGljb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JhZ2UubWlzc2luZy5hZGQobmFtZSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZEljb25Ub1N0b3JhZ2Uoc3RvcmFnZSwgbmFtZSwgaWNvbikge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgaWNvbi5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzdG9yYWdlLmljb25zW25hbWVdID0geyAuLi5pY29uIH07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpc3RJY29ucyhwcm92aWRlciwgcHJlZml4KSB7XG4gIGxldCBhbGxJY29ucyA9IFtdO1xuICBjb25zdCBwcm92aWRlcnMgPSB0eXBlb2YgcHJvdmlkZXIgPT09IFwic3RyaW5nXCIgPyBbcHJvdmlkZXJdIDogT2JqZWN0LmtleXMoZGF0YVN0b3JhZ2UpO1xuICBwcm92aWRlcnMuZm9yRWFjaCgocHJvdmlkZXIyKSA9PiB7XG4gICAgY29uc3QgcHJlZml4ZXMgPSB0eXBlb2YgcHJvdmlkZXIyID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwcmVmaXggPT09IFwic3RyaW5nXCIgPyBbcHJlZml4XSA6IE9iamVjdC5rZXlzKGRhdGFTdG9yYWdlW3Byb3ZpZGVyMl0gfHwge30pO1xuICAgIHByZWZpeGVzLmZvckVhY2goKHByZWZpeDIpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyMiwgcHJlZml4Mik7XG4gICAgICBhbGxJY29ucyA9IGFsbEljb25zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc3RvcmFnZS5pY29ucykubWFwKFxuICAgICAgICAgIChuYW1lKSA9PiAocHJvdmlkZXIyICE9PSBcIlwiID8gXCJAXCIgKyBwcm92aWRlcjIgKyBcIjpcIiA6IFwiXCIpICsgcHJlZml4MiArIFwiOlwiICsgbmFtZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGFsbEljb25zO1xufVxuXG5sZXQgc2ltcGxlTmFtZXMgPSBmYWxzZTtcbmZ1bmN0aW9uIGFsbG93U2ltcGxlTmFtZXMoYWxsb3cpIHtcbiAgaWYgKHR5cGVvZiBhbGxvdyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICBzaW1wbGVOYW1lcyA9IGFsbG93O1xuICB9XG4gIHJldHVybiBzaW1wbGVOYW1lcztcbn1cbmZ1bmN0aW9uIGdldEljb25EYXRhKG5hbWUpIHtcbiAgY29uc3QgaWNvbiA9IHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9JY29uKG5hbWUsIHRydWUsIHNpbXBsZU5hbWVzKSA6IG5hbWU7XG4gIGlmIChpY29uKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoaWNvbi5wcm92aWRlciwgaWNvbi5wcmVmaXgpO1xuICAgIGNvbnN0IGljb25OYW1lID0gaWNvbi5uYW1lO1xuICAgIHJldHVybiBzdG9yYWdlLmljb25zW2ljb25OYW1lXSB8fCAoc3RvcmFnZS5taXNzaW5nLmhhcyhpY29uTmFtZSkgPyBudWxsIDogdm9pZCAwKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkSWNvbihuYW1lLCBkYXRhKSB7XG4gIGNvbnN0IGljb24gPSBzdHJpbmdUb0ljb24obmFtZSwgdHJ1ZSwgc2ltcGxlTmFtZXMpO1xuICBpZiAoIWljb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoaWNvbi5wcm92aWRlciwgaWNvbi5wcmVmaXgpO1xuICBpZiAoZGF0YSkge1xuICAgIHJldHVybiBhZGRJY29uVG9TdG9yYWdlKHN0b3JhZ2UsIGljb24ubmFtZSwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RvcmFnZS5taXNzaW5nLmFkZChpY29uLm5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBhZGRDb2xsZWN0aW9uKGRhdGEsIHByb3ZpZGVyKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3ZpZGVyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcHJvdmlkZXIgPSBkYXRhLnByb3ZpZGVyIHx8IFwiXCI7XG4gIH1cbiAgaWYgKHNpbXBsZU5hbWVzICYmICFwcm92aWRlciAmJiAhZGF0YS5wcmVmaXgpIHtcbiAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICBpZiAocXVpY2tseVZhbGlkYXRlSWNvblNldChkYXRhKSkge1xuICAgICAgZGF0YS5wcmVmaXggPSBcIlwiO1xuICAgICAgcGFyc2VJY29uU2V0KGRhdGEsIChuYW1lLCBpY29uKSA9PiB7XG4gICAgICAgIGlmIChhZGRJY29uKG5hbWUsIGljb24pKSB7XG4gICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGRhdGEucHJlZml4O1xuICBpZiAoIXZhbGlkYXRlSWNvbk5hbWUoe1xuICAgIHByZWZpeCxcbiAgICBuYW1lOiBcImFcIlxuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KTtcbiAgcmV0dXJuICEhYWRkSWNvblNldChzdG9yYWdlLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGljb25Mb2FkZWQobmFtZSkge1xuICByZXR1cm4gISFnZXRJY29uRGF0YShuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEljb24obmFtZSkge1xuICBjb25zdCByZXN1bHQgPSBnZXRJY29uRGF0YShuYW1lKTtcbiAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAuLi5kZWZhdWx0SWNvblByb3BzLFxuICAgIC4uLnJlc3VsdFxuICB9IDogcmVzdWx0O1xufVxuXG5jb25zdCBkZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICB3aWR0aDogbnVsbCxcbiAgaGVpZ2h0OiBudWxsXG59KTtcbmNvbnN0IGRlZmF1bHRJY29uQ3VzdG9taXNhdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgLy8gRGltZW5zaW9uc1xuICAuLi5kZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucyxcbiAgLy8gVHJhbnNmb3JtYXRpb25zXG4gIC4uLmRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zXG59KTtcblxuY29uc3QgdW5pdHNTcGxpdCA9IC8oLT9bMC05Ll0qWzAtOV0rWzAtOS5dKikvZztcbmNvbnN0IHVuaXRzVGVzdCA9IC9eLT9bMC05Ll0qWzAtOV0rWzAtOS5dKiQvZztcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpemUoc2l6ZSwgcmF0aW8sIHByZWNpc2lvbikge1xuICBpZiAocmF0aW8gPT09IDEpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMTAwO1xuICBpZiAodHlwZW9mIHNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHNpemUgKiByYXRpbyAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgY29uc3Qgb2xkUGFydHMgPSBzaXplLnNwbGl0KHVuaXRzU3BsaXQpO1xuICBpZiAob2xkUGFydHMgPT09IG51bGwgfHwgIW9sZFBhcnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGNvbnN0IG5ld1BhcnRzID0gW107XG4gIGxldCBjb2RlID0gb2xkUGFydHMuc2hpZnQoKTtcbiAgbGV0IGlzTnVtYmVyID0gdW5pdHNUZXN0LnRlc3QoY29kZSk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGlzTnVtYmVyKSB7XG4gICAgICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KGNvZGUpO1xuICAgICAgaWYgKGlzTmFOKG51bSkpIHtcbiAgICAgICAgbmV3UGFydHMucHVzaChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1BhcnRzLnB1c2goTWF0aC5jZWlsKG51bSAqIHJhdGlvICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1BhcnRzLnB1c2goY29kZSk7XG4gICAgfVxuICAgIGNvZGUgPSBvbGRQYXJ0cy5zaGlmdCgpO1xuICAgIGlmIChjb2RlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBuZXdQYXJ0cy5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBpc051bWJlciA9ICFpc051bWJlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGxpdFNWR0RlZnMoY29udGVudCwgdGFnID0gXCJkZWZzXCIpIHtcbiAgbGV0IGRlZnMgPSBcIlwiO1xuICBjb25zdCBpbmRleCA9IGNvbnRlbnQuaW5kZXhPZihcIjxcIiArIHRhZyk7XG4gIHdoaWxlIChpbmRleCA+PSAwKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBjb250ZW50LmluZGV4T2YoXCI+XCIsIGluZGV4KTtcbiAgICBjb25zdCBlbmQgPSBjb250ZW50LmluZGV4T2YoXCI8L1wiICsgdGFnKTtcbiAgICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBlbmRFbmQgPSBjb250ZW50LmluZGV4T2YoXCI+XCIsIGVuZCk7XG4gICAgaWYgKGVuZEVuZCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZzICs9IGNvbnRlbnQuc2xpY2Uoc3RhcnQgKyAxLCBlbmQpLnRyaW0oKTtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgwLCBpbmRleCkudHJpbSgpICsgY29udGVudC5zbGljZShlbmRFbmQgKyAxKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRlZnMsXG4gICAgY29udGVudFxuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VEZWZzQW5kQ29udGVudChkZWZzLCBjb250ZW50KSB7XG4gIHJldHVybiBkZWZzID8gXCI8ZGVmcz5cIiArIGRlZnMgKyBcIjwvZGVmcz5cIiArIGNvbnRlbnQgOiBjb250ZW50O1xufVxuZnVuY3Rpb24gd3JhcFNWR0NvbnRlbnQoYm9keSwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBzcGxpdCA9IHNwbGl0U1ZHRGVmcyhib2R5KTtcbiAgcmV0dXJuIG1lcmdlRGVmc0FuZENvbnRlbnQoc3BsaXQuZGVmcywgc3RhcnQgKyBzcGxpdC5jb250ZW50ICsgZW5kKTtcbn1cblxuY29uc3QgaXNVbnNldEtleXdvcmQgPSAodmFsdWUpID0+IHZhbHVlID09PSBcInVuc2V0XCIgfHwgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsdWUgPT09IFwibm9uZVwiO1xuZnVuY3Rpb24gaWNvblRvU1ZHKGljb24sIGN1c3RvbWlzYXRpb25zKSB7XG4gIGNvbnN0IGZ1bGxJY29uID0ge1xuICAgIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gICAgLi4uaWNvblxuICB9O1xuICBjb25zdCBmdWxsQ3VzdG9taXNhdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyxcbiAgICAuLi5jdXN0b21pc2F0aW9uc1xuICB9O1xuICBjb25zdCBib3ggPSB7XG4gICAgbGVmdDogZnVsbEljb24ubGVmdCxcbiAgICB0b3A6IGZ1bGxJY29uLnRvcCxcbiAgICB3aWR0aDogZnVsbEljb24ud2lkdGgsXG4gICAgaGVpZ2h0OiBmdWxsSWNvbi5oZWlnaHRcbiAgfTtcbiAgbGV0IGJvZHkgPSBmdWxsSWNvbi5ib2R5O1xuICBbZnVsbEljb24sIGZ1bGxDdXN0b21pc2F0aW9uc10uZm9yRWFjaCgocHJvcHMpID0+IHtcbiAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBoRmxpcCA9IHByb3BzLmhGbGlwO1xuICAgIGNvbnN0IHZGbGlwID0gcHJvcHMudkZsaXA7XG4gICAgbGV0IHJvdGF0aW9uID0gcHJvcHMucm90YXRlO1xuICAgIGlmIChoRmxpcCkge1xuICAgICAgaWYgKHZGbGlwKSB7XG4gICAgICAgIHJvdGF0aW9uICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcbiAgICAgICAgICBcInRyYW5zbGF0ZShcIiArIChib3gud2lkdGggKyBib3gubGVmdCkudG9TdHJpbmcoKSArIFwiIFwiICsgKDAgLSBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2goXCJzY2FsZSgtMSAxKVwiKTtcbiAgICAgICAgYm94LnRvcCA9IGJveC5sZWZ0ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZGbGlwKSB7XG4gICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcbiAgICAgICAgXCJ0cmFuc2xhdGUoXCIgKyAoMCAtIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoYm94LmhlaWdodCArIGJveC50b3ApLnRvU3RyaW5nKCkgKyBcIilcIlxuICAgICAgKTtcbiAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKFwic2NhbGUoMSAtMSlcIik7XG4gICAgICBib3gudG9wID0gYm94LmxlZnQgPSAwO1xuICAgIH1cbiAgICBsZXQgdGVtcFZhbHVlO1xuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uIC09IE1hdGguZmxvb3Iocm90YXRpb24gLyA0KSAqIDQ7XG4gICAgfVxuICAgIHJvdGF0aW9uID0gcm90YXRpb24gJSA0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGVtcFZhbHVlID0gYm94LmhlaWdodCAvIDIgKyBib3gudG9wO1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBcInJvdGF0ZSg5MCBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIgXCIgKyB0ZW1wVmFsdWUudG9TdHJpbmcoKSArIFwiKVwiXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBcInJvdGF0ZSgxODAgXCIgKyAoYm94LndpZHRoIC8gMiArIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoYm94LmhlaWdodCAvIDIgKyBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRlbXBWYWx1ZSA9IGJveC53aWR0aCAvIDIgKyBib3gubGVmdDtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnVuc2hpZnQoXG4gICAgICAgICAgXCJyb3RhdGUoLTkwIFwiICsgdGVtcFZhbHVlLnRvU3RyaW5nKCkgKyBcIiBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChyb3RhdGlvbiAlIDIgPT09IDEpIHtcbiAgICAgIGlmIChib3gubGVmdCAhPT0gYm94LnRvcCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gubGVmdDtcbiAgICAgICAgYm94LmxlZnQgPSBib3gudG9wO1xuICAgICAgICBib3gudG9wID0gdGVtcFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGJveC53aWR0aCAhPT0gYm94LmhlaWdodCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gud2lkdGg7XG4gICAgICAgIGJveC53aWR0aCA9IGJveC5oZWlnaHQ7XG4gICAgICAgIGJveC5oZWlnaHQgPSB0ZW1wVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBib2R5ID0gd3JhcFNWR0NvbnRlbnQoXG4gICAgICAgIGJvZHksXG4gICAgICAgICc8ZyB0cmFuc2Zvcm09XCInICsgdHJhbnNmb3JtYXRpb25zLmpvaW4oXCIgXCIpICsgJ1wiPicsXG4gICAgICAgIFwiPC9nPlwiXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGN1c3RvbWlzYXRpb25zV2lkdGggPSBmdWxsQ3VzdG9taXNhdGlvbnMud2lkdGg7XG4gIGNvbnN0IGN1c3RvbWlzYXRpb25zSGVpZ2h0ID0gZnVsbEN1c3RvbWlzYXRpb25zLmhlaWdodDtcbiAgY29uc3QgYm94V2lkdGggPSBib3gud2lkdGg7XG4gIGNvbnN0IGJveEhlaWdodCA9IGJveC5oZWlnaHQ7XG4gIGxldCB3aWR0aDtcbiAgbGV0IGhlaWdodDtcbiAgaWYgKGN1c3RvbWlzYXRpb25zV2lkdGggPT09IG51bGwpIHtcbiAgICBoZWlnaHQgPSBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gbnVsbCA/IFwiMWVtXCIgOiBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gXCJhdXRvXCIgPyBib3hIZWlnaHQgOiBjdXN0b21pc2F0aW9uc0hlaWdodDtcbiAgICB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoaGVpZ2h0LCBib3hXaWR0aCAvIGJveEhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgd2lkdGggPSBjdXN0b21pc2F0aW9uc1dpZHRoID09PSBcImF1dG9cIiA/IGJveFdpZHRoIDogY3VzdG9taXNhdGlvbnNXaWR0aDtcbiAgICBoZWlnaHQgPSBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gbnVsbCA/IGNhbGN1bGF0ZVNpemUod2lkdGgsIGJveEhlaWdodCAvIGJveFdpZHRoKSA6IGN1c3RvbWlzYXRpb25zSGVpZ2h0ID09PSBcImF1dG9cIiA/IGJveEhlaWdodCA6IGN1c3RvbWlzYXRpb25zSGVpZ2h0O1xuICB9XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3Qgc2V0QXR0ciA9IChwcm9wLCB2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNVbnNldEtleXdvcmQodmFsdWUpKSB7XG4gICAgICBhdHRyaWJ1dGVzW3Byb3BdID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG4gIHNldEF0dHIoXCJ3aWR0aFwiLCB3aWR0aCk7XG4gIHNldEF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgY29uc3Qgdmlld0JveCA9IFtib3gubGVmdCwgYm94LnRvcCwgYm94V2lkdGgsIGJveEhlaWdodF07XG4gIGF0dHJpYnV0ZXMudmlld0JveCA9IHZpZXdCb3guam9pbihcIiBcIik7XG4gIHJldHVybiB7XG4gICAgYXR0cmlidXRlcyxcbiAgICB2aWV3Qm94LFxuICAgIGJvZHlcbiAgfTtcbn1cblxuY29uc3QgcmVnZXggPSAvXFxzaWQ9XCIoXFxTKylcIi9nO1xuY29uc3QgcmFuZG9tUHJlZml4ID0gXCJJY29uaWZ5SWRcIiArIERhdGUubm93KCkudG9TdHJpbmcoMTYpICsgKE1hdGgucmFuZG9tKCkgKiAxNjc3NzIxNiB8IDApLnRvU3RyaW5nKDE2KTtcbmxldCBjb3VudGVyID0gMDtcbmZ1bmN0aW9uIHJlcGxhY2VJRHMoYm9keSwgcHJlZml4ID0gcmFuZG9tUHJlZml4KSB7XG4gIGNvbnN0IGlkcyA9IFtdO1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHJlZ2V4LmV4ZWMoYm9keSkpIHtcbiAgICBpZHMucHVzaChtYXRjaFsxXSk7XG4gIH1cbiAgaWYgKCFpZHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgY29uc3Qgc3VmZml4ID0gXCJzdWZmaXhcIiArIChNYXRoLnJhbmRvbSgpICogMTY3NzcyMTYgfCBEYXRlLm5vdygpKS50b1N0cmluZygxNik7XG4gIGlkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgIGNvbnN0IG5ld0lEID0gdHlwZW9mIHByZWZpeCA9PT0gXCJmdW5jdGlvblwiID8gcHJlZml4KGlkKSA6IHByZWZpeCArIChjb3VudGVyKyspLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgZXNjYXBlZElEID0gaWQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xuICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoXG4gICAgICAvLyBBbGxvd2VkIGNoYXJhY3RlcnMgYmVmb3JlIGlkOiBbIztcIl1cbiAgICAgIC8vIEFsbG93ZWQgY2hhcmFjdGVycyBhZnRlciBpZDogWylcIl0sIC5bYS16XVxuICAgICAgbmV3IFJlZ0V4cCgnKFsjO1wiXSkoJyArIGVzY2FwZWRJRCArICcpKFtcIildfFxcXFwuW2Etel0pJywgXCJnXCIpLFxuICAgICAgXCIkMVwiICsgbmV3SUQgKyBzdWZmaXggKyBcIiQzXCJcbiAgICApO1xuICB9KTtcbiAgYm9keSA9IGJvZHkucmVwbGFjZShuZXcgUmVnRXhwKHN1ZmZpeCwgXCJnXCIpLCBcIlwiKTtcbiAgcmV0dXJuIGJvZHk7XG59XG5cbmNvbnN0IHN0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIHNldEFQSU1vZHVsZShwcm92aWRlciwgaXRlbSkge1xuICBzdG9yYWdlW3Byb3ZpZGVyXSA9IGl0ZW07XG59XG5mdW5jdGlvbiBnZXRBUElNb2R1bGUocHJvdmlkZXIpIHtcbiAgcmV0dXJuIHN0b3JhZ2VbcHJvdmlkZXJdIHx8IHN0b3JhZ2VbXCJcIl07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFQSUNvbmZpZyhzb3VyY2UpIHtcbiAgbGV0IHJlc291cmNlcztcbiAgaWYgKHR5cGVvZiBzb3VyY2UucmVzb3VyY2VzID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmVzb3VyY2VzID0gW3NvdXJjZS5yZXNvdXJjZXNdO1xuICB9IGVsc2Uge1xuICAgIHJlc291cmNlcyA9IHNvdXJjZS5yZXNvdXJjZXM7XG4gICAgaWYgKCEocmVzb3VyY2VzIGluc3RhbmNlb2YgQXJyYXkpIHx8ICFyZXNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC8vIEFQSSBob3N0c1xuICAgIHJlc291cmNlcyxcbiAgICAvLyBSb290IHBhdGhcbiAgICBwYXRoOiBzb3VyY2UucGF0aCB8fCBcIi9cIixcbiAgICAvLyBVUkwgbGVuZ3RoIGxpbWl0XG4gICAgbWF4VVJMOiBzb3VyY2UubWF4VVJMIHx8IDUwMCxcbiAgICAvLyBUaW1lb3V0IGJlZm9yZSBuZXh0IGhvc3QgaXMgdXNlZC5cbiAgICByb3RhdGU6IHNvdXJjZS5yb3RhdGUgfHwgNzUwLFxuICAgIC8vIFRpbWVvdXQgYmVmb3JlIGZhaWxpbmcgcXVlcnkuXG4gICAgdGltZW91dDogc291cmNlLnRpbWVvdXQgfHwgNWUzLFxuICAgIC8vIFJhbmRvbWlzZSBkZWZhdWx0IEFQSSBlbmQgcG9pbnQuXG4gICAgcmFuZG9tOiBzb3VyY2UucmFuZG9tID09PSB0cnVlLFxuICAgIC8vIFN0YXJ0IGluZGV4XG4gICAgaW5kZXg6IHNvdXJjZS5pbmRleCB8fCAwLFxuICAgIC8vIFJlY2VpdmUgZGF0YSBhZnRlciB0aW1lIG91dCAodXNlZCBpZiB0aW1lIG91dCBraWNrcyBpbiBmaXJzdCwgdGhlbiBBUEkgbW9kdWxlIHNlbmRzIGRhdGEgYW55d2F5KS5cbiAgICBkYXRhQWZ0ZXJUaW1lb3V0OiBzb3VyY2UuZGF0YUFmdGVyVGltZW91dCAhPT0gZmFsc2VcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGNvbmZpZ1N0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IGZhbGxCYWNrQVBJU291cmNlcyA9IFtcbiAgXCJodHRwczovL2FwaS5zaW1wbGVzdmcuY29tXCIsXG4gIFwiaHR0cHM6Ly9hcGkudW5pc3ZnLmNvbVwiXG5dO1xuY29uc3QgZmFsbEJhY2tBUEkgPSBbXTtcbndoaWxlIChmYWxsQmFja0FQSVNvdXJjZXMubGVuZ3RoID4gMCkge1xuICBpZiAoZmFsbEJhY2tBUElTb3VyY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgIGZhbGxCYWNrQVBJLnB1c2goZmFsbEJhY2tBUElTb3VyY2VzLnNoaWZ0KCkpO1xuICB9IGVsc2Uge1xuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICBmYWxsQmFja0FQSS5wdXNoKGZhbGxCYWNrQVBJU291cmNlcy5zaGlmdCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFsbEJhY2tBUEkucHVzaChmYWxsQmFja0FQSVNvdXJjZXMucG9wKCkpO1xuICAgIH1cbiAgfVxufVxuY29uZmlnU3RvcmFnZVtcIlwiXSA9IGNyZWF0ZUFQSUNvbmZpZyh7XG4gIHJlc291cmNlczogW1wiaHR0cHM6Ly9hcGkuaWNvbmlmeS5kZXNpZ25cIl0uY29uY2F0KGZhbGxCYWNrQVBJKVxufSk7XG5mdW5jdGlvbiBhZGRBUElQcm92aWRlcihwcm92aWRlciwgY3VzdG9tQ29uZmlnKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUFQSUNvbmZpZyhjdXN0b21Db25maWcpO1xuICBpZiAoY29uZmlnID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbmZpZ1N0b3JhZ2VbcHJvdmlkZXJdID0gY29uZmlnO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEFQSUNvbmZpZyhwcm92aWRlcikge1xuICByZXR1cm4gY29uZmlnU3RvcmFnZVtwcm92aWRlcl07XG59XG5mdW5jdGlvbiBsaXN0QVBJUHJvdmlkZXJzKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoY29uZmlnU3RvcmFnZSk7XG59XG5cbmNvbnN0IGRldGVjdEZldGNoID0gKCkgPT4ge1xuICBsZXQgY2FsbGJhY2s7XG4gIHRyeSB7XG4gICAgY2FsbGJhY2sgPSBmZXRjaDtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG59O1xubGV0IGZldGNoTW9kdWxlID0gZGV0ZWN0RmV0Y2goKTtcbmZ1bmN0aW9uIHNldEZldGNoKGZldGNoMikge1xuICBmZXRjaE1vZHVsZSA9IGZldGNoMjtcbn1cbmZ1bmN0aW9uIGdldEZldGNoKCkge1xuICByZXR1cm4gZmV0Y2hNb2R1bGU7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVNYXhMZW5ndGgocHJvdmlkZXIsIHByZWZpeCkge1xuICBjb25zdCBjb25maWcgPSBnZXRBUElDb25maWcocHJvdmlkZXIpO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCByZXN1bHQ7XG4gIGlmICghY29uZmlnLm1heFVSTCkge1xuICAgIHJlc3VsdCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGV0IG1heEhvc3RMZW5ndGggPSAwO1xuICAgIGNvbmZpZy5yZXNvdXJjZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgaG9zdCA9IGl0ZW07XG4gICAgICBtYXhIb3N0TGVuZ3RoID0gTWF0aC5tYXgobWF4SG9zdExlbmd0aCwgaG9zdC5sZW5ndGgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHVybCA9IHByZWZpeCArIFwiLmpzb24/aWNvbnM9XCI7XG4gICAgcmVzdWx0ID0gY29uZmlnLm1heFVSTCAtIG1heEhvc3RMZW5ndGggLSBjb25maWcucGF0aC5sZW5ndGggLSB1cmwubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzaG91bGRBYm9ydChzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gNDA0O1xufVxuY29uc3QgcHJlcGFyZSA9IChwcm92aWRlciwgcHJlZml4LCBpY29ucykgPT4ge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGNvbnN0IG1heExlbmd0aCA9IGNhbGN1bGF0ZU1heExlbmd0aChwcm92aWRlciwgcHJlZml4KTtcbiAgY29uc3QgdHlwZSA9IFwiaWNvbnNcIjtcbiAgbGV0IGl0ZW0gPSB7XG4gICAgdHlwZSxcbiAgICBwcm92aWRlcixcbiAgICBwcmVmaXgsXG4gICAgaWNvbnM6IFtdXG4gIH07XG4gIGxldCBsZW5ndGggPSAwO1xuICBpY29ucy5mb3JFYWNoKChuYW1lLCBpbmRleCkgPT4ge1xuICAgIGxlbmd0aCArPSBuYW1lLmxlbmd0aCArIDE7XG4gICAgaWYgKGxlbmd0aCA+PSBtYXhMZW5ndGggJiYgaW5kZXggPiAwKSB7XG4gICAgICByZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgcHJlZml4LFxuICAgICAgICBpY29uczogW11cbiAgICAgIH07XG4gICAgICBsZW5ndGggPSBuYW1lLmxlbmd0aDtcbiAgICB9XG4gICAgaXRlbS5pY29ucy5wdXNoKG5hbWUpO1xuICB9KTtcbiAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICByZXR1cm4gcmVzdWx0cztcbn07XG5mdW5jdGlvbiBnZXRQYXRoKHByb3ZpZGVyKSB7XG4gIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBjb25maWcgPSBnZXRBUElDb25maWcocHJvdmlkZXIpO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHJldHVybiBjb25maWcucGF0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiL1wiO1xufVxuY29uc3Qgc2VuZCA9IChob3N0LCBwYXJhbXMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICghZmV0Y2hNb2R1bGUpIHtcbiAgICBjYWxsYmFjayhcImFib3J0XCIsIDQyNCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBwYXRoID0gZ2V0UGF0aChwYXJhbXMucHJvdmlkZXIpO1xuICBzd2l0Y2ggKHBhcmFtcy50eXBlKSB7XG4gICAgY2FzZSBcImljb25zXCI6IHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHBhcmFtcy5wcmVmaXg7XG4gICAgICBjb25zdCBpY29ucyA9IHBhcmFtcy5pY29ucztcbiAgICAgIGNvbnN0IGljb25zTGlzdCA9IGljb25zLmpvaW4oXCIsXCIpO1xuICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGljb25zOiBpY29uc0xpc3RcbiAgICAgIH0pO1xuICAgICAgcGF0aCArPSBwcmVmaXggKyBcIi5qc29uP1wiICsgdXJsUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImN1c3RvbVwiOiB7XG4gICAgICBjb25zdCB1cmkgPSBwYXJhbXMudXJpO1xuICAgICAgcGF0aCArPSB1cmkuc2xpY2UoMCwgMSkgPT09IFwiL1wiID8gdXJpLnNsaWNlKDEpIDogdXJpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBjYWxsYmFjayhcImFib3J0XCIsIDQwMCk7XG4gICAgICByZXR1cm47XG4gIH1cbiAgbGV0IGRlZmF1bHRFcnJvciA9IDUwMztcbiAgZmV0Y2hNb2R1bGUoaG9zdCArIHBhdGgpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIGlmIChzdGF0dXMgIT09IDIwMCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKHNob3VsZEFib3J0KHN0YXR1cykgPyBcImFib3J0XCIgOiBcIm5leHRcIiwgc3RhdHVzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWZhdWx0RXJyb3IgPSA1MDE7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSkudGhlbigoZGF0YSkgPT4ge1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIiB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGRhdGEgPT09IDQwNCkge1xuICAgICAgICAgIGNhbGxiYWNrKFwiYWJvcnRcIiwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soXCJuZXh0XCIsIGRlZmF1bHRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNhbGxiYWNrKFwic3VjY2Vzc1wiLCBkYXRhKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2goKCkgPT4ge1xuICAgIGNhbGxiYWNrKFwibmV4dFwiLCBkZWZhdWx0RXJyb3IpO1xuICB9KTtcbn07XG5jb25zdCBmZXRjaEFQSU1vZHVsZSA9IHtcbiAgcHJlcGFyZSxcbiAgc2VuZFxufTtcblxuZnVuY3Rpb24gc29ydEljb25zKGljb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBsb2FkZWQ6IFtdLFxuICAgIG1pc3Npbmc6IFtdLFxuICAgIHBlbmRpbmc6IFtdXG4gIH07XG4gIGNvbnN0IHN0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWNvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChhLnByb3ZpZGVyICE9PSBiLnByb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gYS5wcm92aWRlci5sb2NhbGVDb21wYXJlKGIucHJvdmlkZXIpO1xuICAgIH1cbiAgICBpZiAoYS5wcmVmaXggIT09IGIucHJlZml4KSB7XG4gICAgICByZXR1cm4gYS5wcmVmaXgubG9jYWxlQ29tcGFyZShiLnByZWZpeCk7XG4gICAgfVxuICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICB9KTtcbiAgbGV0IGxhc3RJY29uID0ge1xuICAgIHByb3ZpZGVyOiBcIlwiLFxuICAgIHByZWZpeDogXCJcIixcbiAgICBuYW1lOiBcIlwiXG4gIH07XG4gIGljb25zLmZvckVhY2goKGljb24pID0+IHtcbiAgICBpZiAobGFzdEljb24ubmFtZSA9PT0gaWNvbi5uYW1lICYmIGxhc3RJY29uLnByZWZpeCA9PT0gaWNvbi5wcmVmaXggJiYgbGFzdEljb24ucHJvdmlkZXIgPT09IGljb24ucHJvdmlkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGFzdEljb24gPSBpY29uO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gaWNvbi5wcm92aWRlcjtcbiAgICBjb25zdCBwcmVmaXggPSBpY29uLnByZWZpeDtcbiAgICBjb25zdCBuYW1lID0gaWNvbi5uYW1lO1xuICAgIGNvbnN0IHByb3ZpZGVyU3RvcmFnZSA9IHN0b3JhZ2VbcHJvdmlkZXJdIHx8IChzdG9yYWdlW3Byb3ZpZGVyXSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICBjb25zdCBsb2NhbFN0b3JhZ2UgPSBwcm92aWRlclN0b3JhZ2VbcHJlZml4XSB8fCAocHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpKTtcbiAgICBsZXQgbGlzdDtcbiAgICBpZiAobmFtZSBpbiBsb2NhbFN0b3JhZ2UuaWNvbnMpIHtcbiAgICAgIGxpc3QgPSByZXN1bHQubG9hZGVkO1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSBcIlwiIHx8IGxvY2FsU3RvcmFnZS5taXNzaW5nLmhhcyhuYW1lKSkge1xuICAgICAgbGlzdCA9IHJlc3VsdC5taXNzaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ID0gcmVzdWx0LnBlbmRpbmc7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICBwcm92aWRlcixcbiAgICAgIHByZWZpeCxcbiAgICAgIG5hbWVcbiAgICB9O1xuICAgIGxpc3QucHVzaChpdGVtKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNhbGxiYWNrKHN0b3JhZ2VzLCBpZCkge1xuICBzdG9yYWdlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcztcbiAgICBpZiAoaXRlbXMpIHtcbiAgICAgIHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzID0gaXRlbXMuZmlsdGVyKChyb3cpID0+IHJvdy5pZCAhPT0gaWQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWxsYmFja3Moc3RvcmFnZSkge1xuICBpZiAoIXN0b3JhZ2UucGVuZGluZ0NhbGxiYWNrc0ZsYWcpIHtcbiAgICBzdG9yYWdlLnBlbmRpbmdDYWxsYmFja3NGbGFnID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN0b3JhZ2UucGVuZGluZ0NhbGxiYWNrc0ZsYWcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gc3RvcmFnZS5sb2FkZXJDYWxsYmFja3MgPyBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcy5zbGljZSgwKSA6IFtdO1xuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGhhc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gc3RvcmFnZS5wcm92aWRlcjtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHN0b3JhZ2UucHJlZml4O1xuICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBpY29ucyA9IGl0ZW0uaWNvbnM7XG4gICAgICAgIGNvbnN0IG9sZExlbmd0aCA9IGljb25zLnBlbmRpbmcubGVuZ3RoO1xuICAgICAgICBpY29ucy5wZW5kaW5nID0gaWNvbnMucGVuZGluZy5maWx0ZXIoKGljb24pID0+IHtcbiAgICAgICAgICBpZiAoaWNvbi5wcmVmaXggIT09IHByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5hbWUgPSBpY29uLm5hbWU7XG4gICAgICAgICAgaWYgKHN0b3JhZ2UuaWNvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGljb25zLmxvYWRlZC5wdXNoKHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yYWdlLm1pc3NpbmcuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBpY29ucy5taXNzaW5nLnB1c2goe1xuICAgICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFzUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGljb25zLnBlbmRpbmcubGVuZ3RoICE9PSBvbGRMZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWhhc1BlbmRpbmcpIHtcbiAgICAgICAgICAgIHJlbW92ZUNhbGxiYWNrKFtzdG9yYWdlXSwgaXRlbS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0uY2FsbGJhY2soXG4gICAgICAgICAgICBpY29ucy5sb2FkZWQuc2xpY2UoMCksXG4gICAgICAgICAgICBpY29ucy5taXNzaW5nLnNsaWNlKDApLFxuICAgICAgICAgICAgaWNvbnMucGVuZGluZy5zbGljZSgwKSxcbiAgICAgICAgICAgIGl0ZW0uYWJvcnRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxubGV0IGlkQ291bnRlciA9IDA7XG5mdW5jdGlvbiBzdG9yZUNhbGxiYWNrKGNhbGxiYWNrLCBpY29ucywgcGVuZGluZ1NvdXJjZXMpIHtcbiAgY29uc3QgaWQgPSBpZENvdW50ZXIrKztcbiAgY29uc3QgYWJvcnQgPSByZW1vdmVDYWxsYmFjay5iaW5kKG51bGwsIHBlbmRpbmdTb3VyY2VzLCBpZCk7XG4gIGlmICghaWNvbnMucGVuZGluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWJvcnQ7XG4gIH1cbiAgY29uc3QgaXRlbSA9IHtcbiAgICBpZCxcbiAgICBpY29ucyxcbiAgICBjYWxsYmFjayxcbiAgICBhYm9ydFxuICB9O1xuICBwZW5kaW5nU291cmNlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgKHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzIHx8IChzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyA9IFtdKSkucHVzaChpdGVtKTtcbiAgfSk7XG4gIHJldHVybiBhYm9ydDtcbn1cblxuZnVuY3Rpb24gbGlzdFRvSWNvbnMobGlzdCwgdmFsaWRhdGUgPSB0cnVlLCBzaW1wbGVOYW1lcyA9IGZhbHNlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBjb25zdCBpY29uID0gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24oaXRlbSwgdmFsaWRhdGUsIHNpbXBsZU5hbWVzKSA6IGl0ZW07XG4gICAgaWYgKGljb24pIHtcbiAgICAgIHJlc3VsdC5wdXNoKGljb24pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9jb25maWcudHNcbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuICByZXNvdXJjZXM6IFtdLFxuICBpbmRleDogMCxcbiAgdGltZW91dDogMmUzLFxuICByb3RhdGU6IDc1MCxcbiAgcmFuZG9tOiBmYWxzZSxcbiAgZGF0YUFmdGVyVGltZW91dDogZmFsc2Vcbn07XG5cbi8vIHNyYy9xdWVyeS50c1xuZnVuY3Rpb24gc2VuZFF1ZXJ5KGNvbmZpZywgcGF5bG9hZCwgcXVlcnksIGRvbmUpIHtcbiAgY29uc3QgcmVzb3VyY2VzQ291bnQgPSBjb25maWcucmVzb3VyY2VzLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IGNvbmZpZy5yYW5kb20gPyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByZXNvdXJjZXNDb3VudCkgOiBjb25maWcuaW5kZXg7XG4gIGxldCByZXNvdXJjZXM7XG4gIGlmIChjb25maWcucmFuZG9tKSB7XG4gICAgbGV0IGxpc3QgPSBjb25maWcucmVzb3VyY2VzLnNsaWNlKDApO1xuICAgIHJlc291cmNlcyA9IFtdO1xuICAgIHdoaWxlIChsaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IG5leHRJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxpc3QubGVuZ3RoKTtcbiAgICAgIHJlc291cmNlcy5wdXNoKGxpc3RbbmV4dEluZGV4XSk7XG4gICAgICBsaXN0ID0gbGlzdC5zbGljZSgwLCBuZXh0SW5kZXgpLmNvbmNhdChsaXN0LnNsaWNlKG5leHRJbmRleCArIDEpKTtcbiAgICB9XG4gICAgcmVzb3VyY2VzID0gcmVzb3VyY2VzLmNvbmNhdChsaXN0KTtcbiAgfSBlbHNlIHtcbiAgICByZXNvdXJjZXMgPSBjb25maWcucmVzb3VyY2VzLnNsaWNlKHN0YXJ0SW5kZXgpLmNvbmNhdChjb25maWcucmVzb3VyY2VzLnNsaWNlKDAsIHN0YXJ0SW5kZXgpKTtcbiAgfVxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICBsZXQgc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gIGxldCBxdWVyaWVzU2VudCA9IDA7XG4gIGxldCBsYXN0RXJyb3I7XG4gIGxldCB0aW1lciA9IG51bGw7XG4gIGxldCBxdWV1ZSA9IFtdO1xuICBsZXQgZG9uZUNhbGxiYWNrcyA9IFtdO1xuICBpZiAodHlwZW9mIGRvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRvbmVDYWxsYmFja3MucHVzaChkb25lKTtcbiAgfVxuICBmdW5jdGlvbiByZXNldFRpbWVyKCkge1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIHN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICByZXNldFRpbWVyKCk7XG4gICAgcXVldWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICBpdGVtLnN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHF1ZXVlID0gW107XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrLCBvdmVyd3JpdGUpIHtcbiAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICBkb25lQ2FsbGJhY2tzID0gW107XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZG9uZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UXVlcnlTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIHBheWxvYWQsXG4gICAgICBzdGF0dXMsXG4gICAgICBxdWVyaWVzU2VudCxcbiAgICAgIHF1ZXJpZXNQZW5kaW5nOiBxdWV1ZS5sZW5ndGgsXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBhYm9ydFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZmFpbFF1ZXJ5KCkge1xuICAgIHN0YXR1cyA9IFwiZmFpbGVkXCI7XG4gICAgZG9uZUNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgY2FsbGJhY2sodm9pZCAwLCBsYXN0RXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUXVldWUoKSB7XG4gICAgcXVldWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICBpdGVtLnN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHF1ZXVlID0gW107XG4gIH1cbiAgZnVuY3Rpb24gbW9kdWxlUmVzcG9uc2UoaXRlbSwgcmVzcG9uc2UsIGRhdGEpIHtcbiAgICBjb25zdCBpc0Vycm9yID0gcmVzcG9uc2UgIT09IFwic3VjY2Vzc1wiO1xuICAgIHF1ZXVlID0gcXVldWUuZmlsdGVyKChxdWV1ZWQpID0+IHF1ZXVlZCAhPT0gaXRlbSk7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICBpZiAoaXNFcnJvciB8fCAhY29uZmlnLmRhdGFBZnRlclRpbWVvdXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXNwb25zZSA9PT0gXCJhYm9ydFwiKSB7XG4gICAgICBsYXN0RXJyb3IgPSBkYXRhO1xuICAgICAgZmFpbFF1ZXJ5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICBsYXN0RXJyb3IgPSBkYXRhO1xuICAgICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFyZXNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZmFpbFF1ZXJ5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhlY05leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNldFRpbWVyKCk7XG4gICAgY2xlYXJRdWV1ZSgpO1xuICAgIGlmICghY29uZmlnLnJhbmRvbSkge1xuICAgICAgY29uc3QgaW5kZXggPSBjb25maWcucmVzb3VyY2VzLmluZGV4T2YoaXRlbS5yZXNvdXJjZSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xICYmIGluZGV4ICE9PSBjb25maWcuaW5kZXgpIHtcbiAgICAgICAgY29uZmlnLmluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXR1cyA9IFwiY29tcGxldGVkXCI7XG4gICAgZG9uZUNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZXhlY05leHQoKSB7XG4gICAgaWYgKHN0YXR1cyAhPT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzZXRUaW1lcigpO1xuICAgIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKHJlc291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZXNldFRpbWVyKCk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIGNsZWFyUXVldWUoKTtcbiAgICAgICAgICAgIGZhaWxRdWVyeSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmYWlsUXVlcnkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHtcbiAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICByZXNvdXJjZSxcbiAgICAgIGNhbGxiYWNrOiAoc3RhdHVzMiwgZGF0YSkgPT4ge1xuICAgICAgICBtb2R1bGVSZXNwb25zZShpdGVtLCBzdGF0dXMyLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgcXVlcmllc1NlbnQrKztcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZXhlY05leHQsIGNvbmZpZy5yb3RhdGUpO1xuICAgIHF1ZXJ5KHJlc291cmNlLCBwYXlsb2FkLCBpdGVtLmNhbGxiYWNrKTtcbiAgfVxuICBzZXRUaW1lb3V0KGV4ZWNOZXh0KTtcbiAgcmV0dXJuIGdldFF1ZXJ5U3RhdHVzO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGluaXRSZWR1bmRhbmN5KGNmZykge1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAuLi5jZmdcbiAgfTtcbiAgbGV0IHF1ZXJpZXMgPSBbXTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBxdWVyaWVzID0gcXVlcmllcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0oKS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKTtcbiAgfVxuICBmdW5jdGlvbiBxdWVyeShwYXlsb2FkLCBxdWVyeUNhbGxiYWNrLCBkb25lQ2FsbGJhY2spIHtcbiAgICBjb25zdCBxdWVyeTIgPSBzZW5kUXVlcnkoXG4gICAgICBjb25maWcsXG4gICAgICBwYXlsb2FkLFxuICAgICAgcXVlcnlDYWxsYmFjayxcbiAgICAgIChkYXRhLCBlcnJvcikgPT4ge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGlmIChkb25lQ2FsbGJhY2spIHtcbiAgICAgICAgICBkb25lQ2FsbGJhY2soZGF0YSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBxdWVyaWVzLnB1c2gocXVlcnkyKTtcbiAgICByZXR1cm4gcXVlcnkyO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcXVlcmllcy5maW5kKCh2YWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlKTtcbiAgICB9KSB8fCBudWxsO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlID0ge1xuICAgIHF1ZXJ5LFxuICAgIGZpbmQsXG4gICAgc2V0SW5kZXg6IChpbmRleCkgPT4ge1xuICAgICAgY29uZmlnLmluZGV4ID0gaW5kZXg7XG4gICAgfSxcbiAgICBnZXRJbmRleDogKCkgPT4gY29uZmlnLmluZGV4LFxuICAgIGNsZWFudXBcbiAgfTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBlbXB0eUNhbGxiYWNrJDEoKSB7XG59XG5jb25zdCByZWR1bmRhbmN5Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGdldFJlZHVuZGFuY3lDYWNoZShwcm92aWRlcikge1xuICBpZiAoIXJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl0pIHtcbiAgICBjb25zdCBjb25maWcgPSBnZXRBUElDb25maWcocHJvdmlkZXIpO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlZHVuZGFuY3kgPSBpbml0UmVkdW5kYW5jeShjb25maWcpO1xuICAgIGNvbnN0IGNhY2hlZFJldW5kYW5jeSA9IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlZHVuZGFuY3lcbiAgICB9O1xuICAgIHJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl0gPSBjYWNoZWRSZXVuZGFuY3k7XG4gIH1cbiAgcmV0dXJuIHJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl07XG59XG5mdW5jdGlvbiBzZW5kQVBJUXVlcnkodGFyZ2V0LCBxdWVyeSwgY2FsbGJhY2spIHtcbiAgbGV0IHJlZHVuZGFuY3k7XG4gIGxldCBzZW5kO1xuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGFwaSA9IGdldEFQSU1vZHVsZSh0YXJnZXQpO1xuICAgIGlmICghYXBpKSB7XG4gICAgICBjYWxsYmFjayh2b2lkIDAsIDQyNCk7XG4gICAgICByZXR1cm4gZW1wdHlDYWxsYmFjayQxO1xuICAgIH1cbiAgICBzZW5kID0gYXBpLnNlbmQ7XG4gICAgY29uc3QgY2FjaGVkID0gZ2V0UmVkdW5kYW5jeUNhY2hlKHRhcmdldCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmVkdW5kYW5jeSA9IGNhY2hlZC5yZWR1bmRhbmN5O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb25maWcgPSBjcmVhdGVBUElDb25maWcodGFyZ2V0KTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICByZWR1bmRhbmN5ID0gaW5pdFJlZHVuZGFuY3koY29uZmlnKTtcbiAgICAgIGNvbnN0IG1vZHVsZUtleSA9IHRhcmdldC5yZXNvdXJjZXMgPyB0YXJnZXQucmVzb3VyY2VzWzBdIDogXCJcIjtcbiAgICAgIGNvbnN0IGFwaSA9IGdldEFQSU1vZHVsZShtb2R1bGVLZXkpO1xuICAgICAgaWYgKGFwaSkge1xuICAgICAgICBzZW5kID0gYXBpLnNlbmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghcmVkdW5kYW5jeSB8fCAhc2VuZCkge1xuICAgIGNhbGxiYWNrKHZvaWQgMCwgNDI0KTtcbiAgICByZXR1cm4gZW1wdHlDYWxsYmFjayQxO1xuICB9XG4gIHJldHVybiByZWR1bmRhbmN5LnF1ZXJ5KHF1ZXJ5LCBzZW5kLCBjYWxsYmFjaykoKS5hYm9ydDtcbn1cblxuZnVuY3Rpb24gZW1wdHlDYWxsYmFjaygpIHtcbn1cbmZ1bmN0aW9uIGxvYWRlZE5ld0ljb25zKHN0b3JhZ2UpIHtcbiAgaWYgKCFzdG9yYWdlLmljb25zTG9hZGVyRmxhZykge1xuICAgIHN0b3JhZ2UuaWNvbnNMb2FkZXJGbGFnID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN0b3JhZ2UuaWNvbnNMb2FkZXJGbGFnID0gZmFsc2U7XG4gICAgICB1cGRhdGVDYWxsYmFja3Moc3RvcmFnZSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSWNvbk5hbWVzRm9yQVBJKGljb25zKSB7XG4gIGNvbnN0IHZhbGlkID0gW107XG4gIGNvbnN0IGludmFsaWQgPSBbXTtcbiAgaWNvbnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIChuYW1lLm1hdGNoKG1hdGNoSWNvbk5hbWUpID8gdmFsaWQgOiBpbnZhbGlkKS5wdXNoKG5hbWUpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB2YWxpZCxcbiAgICBpbnZhbGlkXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIGljb25zLCBkYXRhKSB7XG4gIGZ1bmN0aW9uIGNoZWNrTWlzc2luZygpIHtcbiAgICBjb25zdCBwZW5kaW5nID0gc3RvcmFnZS5wZW5kaW5nSWNvbnM7XG4gICAgaWNvbnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgcGVuZGluZy5kZWxldGUobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0b3JhZ2UuaWNvbnNbbmFtZV0pIHtcbiAgICAgICAgc3RvcmFnZS5taXNzaW5nLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBhZGRJY29uU2V0KHN0b3JhZ2UsIGRhdGEpO1xuICAgICAgaWYgKCFwYXJzZWQubGVuZ3RoKSB7XG4gICAgICAgIGNoZWNrTWlzc2luZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICB9XG4gIGNoZWNrTWlzc2luZygpO1xuICBsb2FkZWROZXdJY29ucyhzdG9yYWdlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUG9zc2libHlBc3luY1Jlc3BvbnNlKHJlc3BvbnNlLCBjYWxsYmFjaykge1xuICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgcmVzcG9uc2UudGhlbigoZGF0YSkgPT4ge1xuICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICB9XG59XG5mdW5jdGlvbiBsb2FkTmV3SWNvbnMoc3RvcmFnZSwgaWNvbnMpIHtcbiAgaWYgKCFzdG9yYWdlLmljb25zVG9Mb2FkKSB7XG4gICAgc3RvcmFnZS5pY29uc1RvTG9hZCA9IGljb25zO1xuICB9IGVsc2Uge1xuICAgIHN0b3JhZ2UuaWNvbnNUb0xvYWQgPSBzdG9yYWdlLmljb25zVG9Mb2FkLmNvbmNhdChpY29ucykuc29ydCgpO1xuICB9XG4gIGlmICghc3RvcmFnZS5pY29uc1F1ZXVlRmxhZykge1xuICAgIHN0b3JhZ2UuaWNvbnNRdWV1ZUZsYWcgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3RvcmFnZS5pY29uc1F1ZXVlRmxhZyA9IGZhbHNlO1xuICAgICAgY29uc3QgeyBwcm92aWRlciwgcHJlZml4IH0gPSBzdG9yYWdlO1xuICAgICAgY29uc3QgaWNvbnMyID0gc3RvcmFnZS5pY29uc1RvTG9hZDtcbiAgICAgIGRlbGV0ZSBzdG9yYWdlLmljb25zVG9Mb2FkO1xuICAgICAgaWYgKCFpY29uczIgfHwgIWljb25zMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VzdG9tSWNvbkxvYWRlciA9IHN0b3JhZ2UubG9hZEljb247XG4gICAgICBpZiAoc3RvcmFnZS5sb2FkSWNvbnMgJiYgKGljb25zMi5sZW5ndGggPiAxIHx8ICFjdXN0b21JY29uTG9hZGVyKSkge1xuICAgICAgICBwYXJzZVBvc3NpYmx5QXN5bmNSZXNwb25zZShcbiAgICAgICAgICBzdG9yYWdlLmxvYWRJY29ucyhpY29uczIsIHByZWZpeCwgcHJvdmlkZXIpLFxuICAgICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIGljb25zMiwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY3VzdG9tSWNvbkxvYWRlcikge1xuICAgICAgICBpY29uczIuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gY3VzdG9tSWNvbkxvYWRlcihuYW1lLCBwcmVmaXgsIHByb3ZpZGVyKTtcbiAgICAgICAgICBwYXJzZVBvc3NpYmx5QXN5bmNSZXNwb25zZShyZXNwb25zZSwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGljb25TZXQgPSBkYXRhID8ge1xuICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgIGljb25zOiB7XG4gICAgICAgICAgICAgICAgW25hbWVdOiBkYXRhXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgICAgcGFyc2VMb2FkZXJSZXNwb25zZShzdG9yYWdlLCBbbmFtZV0sIGljb25TZXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB2YWxpZCwgaW52YWxpZCB9ID0gY2hlY2tJY29uTmFtZXNGb3JBUEkoaWNvbnMyKTtcbiAgICAgIGlmIChpbnZhbGlkLmxlbmd0aCkge1xuICAgICAgICBwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIGludmFsaWQsIG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWxpZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYXBpID0gcHJlZml4Lm1hdGNoKG1hdGNoSWNvbk5hbWUpID8gZ2V0QVBJTW9kdWxlKHByb3ZpZGVyKSA6IG51bGw7XG4gICAgICBpZiAoIWFwaSkge1xuICAgICAgICBwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIHZhbGlkLCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyYW1zID0gYXBpLnByZXBhcmUocHJvdmlkZXIsIHByZWZpeCwgdmFsaWQpO1xuICAgICAgcGFyYW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgc2VuZEFQSVF1ZXJ5KHByb3ZpZGVyLCBpdGVtLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIHBhcnNlTG9hZGVyUmVzcG9uc2Uoc3RvcmFnZSwgaXRlbS5pY29ucywgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGxvYWRJY29ucyA9IChpY29ucywgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgY2xlYW5lZEljb25zID0gbGlzdFRvSWNvbnMoaWNvbnMsIHRydWUsIGFsbG93U2ltcGxlTmFtZXMoKSk7XG4gIGNvbnN0IHNvcnRlZEljb25zID0gc29ydEljb25zKGNsZWFuZWRJY29ucyk7XG4gIGlmICghc29ydGVkSWNvbnMucGVuZGluZy5sZW5ndGgpIHtcbiAgICBsZXQgY2FsbENhbGxiYWNrID0gdHJ1ZTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY2FsbENhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICBzb3J0ZWRJY29ucy5sb2FkZWQsXG4gICAgICAgICAgICBzb3J0ZWRJY29ucy5taXNzaW5nLFxuICAgICAgICAgICAgc29ydGVkSWNvbnMucGVuZGluZyxcbiAgICAgICAgICAgIGVtcHR5Q2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbGxDYWxsYmFjayA9IGZhbHNlO1xuICAgIH07XG4gIH1cbiAgY29uc3QgbmV3SWNvbnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgc291cmNlcyA9IFtdO1xuICBsZXQgbGFzdFByb3ZpZGVyLCBsYXN0UHJlZml4O1xuICBzb3J0ZWRJY29ucy5wZW5kaW5nLmZvckVhY2goKGljb24pID0+IHtcbiAgICBjb25zdCB7IHByb3ZpZGVyLCBwcmVmaXggfSA9IGljb247XG4gICAgaWYgKHByZWZpeCA9PT0gbGFzdFByZWZpeCAmJiBwcm92aWRlciA9PT0gbGFzdFByb3ZpZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIGxhc3RQcmVmaXggPSBwcmVmaXg7XG4gICAgc291cmNlcy5wdXNoKGdldFN0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkpO1xuICAgIGNvbnN0IHByb3ZpZGVyTmV3SWNvbnMgPSBuZXdJY29uc1twcm92aWRlcl0gfHwgKG5ld0ljb25zW3Byb3ZpZGVyXSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICBpZiAoIXByb3ZpZGVyTmV3SWNvbnNbcHJlZml4XSkge1xuICAgICAgcHJvdmlkZXJOZXdJY29uc1twcmVmaXhdID0gW107XG4gICAgfVxuICB9KTtcbiAgc29ydGVkSWNvbnMucGVuZGluZy5mb3JFYWNoKChpY29uKSA9PiB7XG4gICAgY29uc3QgeyBwcm92aWRlciwgcHJlZml4LCBuYW1lIH0gPSBpY29uO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpO1xuICAgIGNvbnN0IHBlbmRpbmdRdWV1ZSA9IHN0b3JhZ2UucGVuZGluZ0ljb25zIHx8IChzdG9yYWdlLnBlbmRpbmdJY29ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIGlmICghcGVuZGluZ1F1ZXVlLmhhcyhuYW1lKSkge1xuICAgICAgcGVuZGluZ1F1ZXVlLmFkZChuYW1lKTtcbiAgICAgIG5ld0ljb25zW3Byb3ZpZGVyXVtwcmVmaXhdLnB1c2gobmFtZSk7XG4gICAgfVxuICB9KTtcbiAgc291cmNlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgY29uc3QgbGlzdCA9IG5ld0ljb25zW3N0b3JhZ2UucHJvdmlkZXJdW3N0b3JhZ2UucHJlZml4XTtcbiAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgIGxvYWROZXdJY29ucyhzdG9yYWdlLCBsaXN0KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2FsbGJhY2sgPyBzdG9yZUNhbGxiYWNrKGNhbGxiYWNrLCBzb3J0ZWRJY29ucywgc291cmNlcykgOiBlbXB0eUNhbGxiYWNrO1xufTtcbmNvbnN0IGxvYWRJY29uID0gKGljb24pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWxsLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpY29uT2JqID0gdHlwZW9mIGljb24gPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24oaWNvbiwgdHJ1ZSkgOiBpY29uO1xuICAgIGlmICghaWNvbk9iaikge1xuICAgICAgcmVqZWN0KGljb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2FkSWNvbnMoW2ljb25PYmogfHwgaWNvbl0sIChsb2FkZWQpID0+IHtcbiAgICAgIGlmIChsb2FkZWQubGVuZ3RoICYmIGljb25PYmopIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEljb25EYXRhKGljb25PYmopO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGZ1bGZpbGwoe1xuICAgICAgICAgICAgLi4uZGVmYXVsdEljb25Qcm9wcyxcbiAgICAgICAgICAgIC4uLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlamVjdChpY29uKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBzZXRDdXN0b21JY29uc0xvYWRlcihsb2FkZXIsIHByZWZpeCwgcHJvdmlkZXIpIHtcbiAgZ2V0U3RvcmFnZShwcm92aWRlciB8fCBcIlwiLCBwcmVmaXgpLmxvYWRJY29ucyA9IGxvYWRlcjtcbn1cbmZ1bmN0aW9uIHNldEN1c3RvbUljb25Mb2FkZXIobG9hZGVyLCBwcmVmaXgsIHByb3ZpZGVyKSB7XG4gIGdldFN0b3JhZ2UocHJvdmlkZXIgfHwgXCJcIiwgcHJlZml4KS5sb2FkSWNvbiA9IGxvYWRlcjtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDdXN0b21pc2F0aW9ucyhkZWZhdWx0cywgaXRlbSkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4uZGVmYXVsdHNcbiAgfTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaXRlbSkge1xuICAgIGNvbnN0IHZhbHVlID0gaXRlbVtrZXldO1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAoa2V5IGluIGRlZmF1bHRJY29uU2l6ZUN1c3RvbWlzYXRpb25zKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgJiYgKHZhbHVlVHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZVR5cGUgPT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09IHR5cGVvZiByZXN1bHRba2V5XSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBrZXkgPT09IFwicm90YXRlXCIgPyB2YWx1ZSAlIDQgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3Qgc2VwYXJhdG9yID0gL1tcXHMsXSsvO1xuZnVuY3Rpb24gZmxpcEZyb21TdHJpbmcoY3VzdG9tLCBmbGlwKSB7XG4gIGZsaXAuc3BsaXQoc2VwYXJhdG9yKS5mb3JFYWNoKChzdHIpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0ci50cmltKCk7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgICAgY3VzdG9tLmhGbGlwID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgY3VzdG9tLnZGbGlwID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcm90YXRlRnJvbVN0cmluZyh2YWx1ZSwgZGVmYXVsdFZhbHVlID0gMCkge1xuICBjb25zdCB1bml0cyA9IHZhbHVlLnJlcGxhY2UoL14tP1swLTkuXSovLCBcIlwiKTtcbiAgZnVuY3Rpb24gY2xlYW51cCh2YWx1ZTIpIHtcbiAgICB3aGlsZSAodmFsdWUyIDwgMCkge1xuICAgICAgdmFsdWUyICs9IDQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTIgJSA0O1xuICB9XG4gIGlmICh1bml0cyA9PT0gXCJcIikge1xuICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICByZXR1cm4gaXNOYU4obnVtKSA/IDAgOiBjbGVhbnVwKG51bSk7XG4gIH0gZWxzZSBpZiAodW5pdHMgIT09IHZhbHVlKSB7XG4gICAgbGV0IHNwbGl0ID0gMDtcbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICBjYXNlIFwiJVwiOlxuICAgICAgICBzcGxpdCA9IDI1O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZWdcIjpcbiAgICAgICAgc3BsaXQgPSA5MDtcbiAgICB9XG4gICAgaWYgKHNwbGl0KSB7XG4gICAgICBsZXQgbnVtID0gcGFyc2VGbG9hdCh2YWx1ZS5zbGljZSgwLCB2YWx1ZS5sZW5ndGggLSB1bml0cy5sZW5ndGgpKTtcbiAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgbnVtID0gbnVtIC8gc3BsaXQ7XG4gICAgICByZXR1cm4gbnVtICUgMSA9PT0gMCA/IGNsZWFudXAobnVtKSA6IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIGljb25Ub0hUTUwoYm9keSwgYXR0cmlidXRlcykge1xuICBsZXQgcmVuZGVyQXR0cmlic0hUTUwgPSBib2R5LmluZGV4T2YoXCJ4bGluazpcIikgPT09IC0xID8gXCJcIiA6ICcgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCInO1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgIHJlbmRlckF0dHJpYnNIVE1MICs9IFwiIFwiICsgYXR0ciArICc9XCInICsgYXR0cmlidXRlc1thdHRyXSArICdcIic7XG4gIH1cbiAgcmV0dXJuICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIicgKyByZW5kZXJBdHRyaWJzSFRNTCArIFwiPlwiICsgYm9keSArIFwiPC9zdmc+XCI7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVNWR2ZvclVSTChzdmcpIHtcbiAgcmV0dXJuIHN2Zy5yZXBsYWNlKC9cIi9nLCBcIidcIikucmVwbGFjZSgvJS9nLCBcIiUyNVwiKS5yZXBsYWNlKC8jL2csIFwiJTIzXCIpLnJlcGxhY2UoLzwvZywgXCIlM0NcIikucmVwbGFjZSgvPi9nLCBcIiUzRVwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbn1cbmZ1bmN0aW9uIHN2Z1RvRGF0YShzdmcpIHtcbiAgcmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sLFwiICsgZW5jb2RlU1ZHZm9yVVJMKHN2Zyk7XG59XG5mdW5jdGlvbiBzdmdUb1VSTChzdmcpIHtcbiAgcmV0dXJuICd1cmwoXCInICsgc3ZnVG9EYXRhKHN2ZykgKyAnXCIpJztcbn1cblxubGV0IHBvbGljeTtcbmZ1bmN0aW9uIGNyZWF0ZVBvbGljeSgpIHtcbiAgdHJ5IHtcbiAgICBwb2xpY3kgPSB3aW5kb3cudHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShcImljb25pZnlcIiwge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICBjcmVhdGVIVE1MOiAocykgPT4gc1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwb2xpY3kgPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhblVwSW5uZXJIVE1MKGh0bWwpIHtcbiAgaWYgKHBvbGljeSA9PT0gdm9pZCAwKSB7XG4gICAgY3JlYXRlUG9saWN5KCk7XG4gIH1cbiAgcmV0dXJuIHBvbGljeSA/IHBvbGljeS5jcmVhdGVIVE1MKGh0bWwpIDogaHRtbDtcbn1cblxuY29uc3QgZGVmYXVsdEV4dGVuZGVkSWNvbkN1c3RvbWlzYXRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRJY29uQ3VzdG9taXNhdGlvbnMsXG4gICAgaW5saW5lOiBmYWxzZSxcbn07XG5cbi8qKlxuICogRGVmYXVsdCBTVkcgYXR0cmlidXRlc1xuICovXG5jb25zdCBzdmdEZWZhdWx0cyA9IHtcbiAgICAneG1sbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICd4bWxuc1hsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgJ3JvbGUnOiAnaW1nJyxcbn07XG4vKipcbiAqIFN0eWxlIG1vZGVzXG4gKi9cbmNvbnN0IGNvbW1vblByb3BzID0ge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxufTtcbmNvbnN0IG1vbm90b25lUHJvcHMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbn07XG5jb25zdCBjb2xvcmVkUHJvcHMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxufTtcbi8vIER5bmFtaWNhbGx5IGFkZCBjb21tb24gcHJvcHMgdG8gdmFyaWFibGVzIGFib3ZlXG5jb25zdCBwcm9wc1RvQWRkID0ge1xuICAgIEltYWdlOiAndmFyKC0tc3ZnKScsXG4gICAgUmVwZWF0OiAnbm8tcmVwZWF0JyxcbiAgICBTaXplOiAnMTAwJSAxMDAlJyxcbn07XG5jb25zdCBwcm9wc1RvQWRkVG8gPSB7XG4gICAgV2Via2l0TWFzazogbW9ub3RvbmVQcm9wcyxcbiAgICBtYXNrOiBtb25vdG9uZVByb3BzLFxuICAgIGJhY2tncm91bmQ6IGNvbG9yZWRQcm9wcyxcbn07XG5mb3IgKGNvbnN0IHByZWZpeCBpbiBwcm9wc1RvQWRkVG8pIHtcbiAgICBjb25zdCBsaXN0ID0gcHJvcHNUb0FkZFRvW3ByZWZpeF07XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzVG9BZGQpIHtcbiAgICAgICAgbGlzdFtwcmVmaXggKyBwcm9wXSA9IHByb3BzVG9BZGRbcHJvcF07XG4gICAgfVxufVxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgY3VzdG9taXNhdGlvbnMgZm9yIGlubGluZSBpY29uXG4gKi9cbmNvbnN0IGlubGluZURlZmF1bHRzID0ge1xuICAgIC4uLmRlZmF1bHRFeHRlbmRlZEljb25DdXN0b21pc2F0aW9ucyxcbiAgICBpbmxpbmU6IHRydWUsXG59O1xuLyoqXG4gKiBGaXggc2l6ZTogYWRkICdweCcgdG8gbnVtYmVyc1xuICovXG5mdW5jdGlvbiBmaXhTaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgKHZhbHVlLm1hdGNoKC9eWy0wLTkuXSskLykgPyAncHgnIDogJycpO1xufVxuLyoqXG4gKiBSZW5kZXIgaWNvblxuICovXG5jb25zdCByZW5kZXIgPSAoXG4vLyBJY29uIG11c3QgYmUgdmFsaWRhdGVkIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb25cbmljb24sIFxuLy8gUGFydGlhbCBwcm9wZXJ0aWVzXG5wcm9wcywgXG4vLyBJY29uIG5hbWVcbm5hbWUpID0+IHtcbiAgICAvLyBHZXQgZGVmYXVsdCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZGVmYXVsdFByb3BzID0gcHJvcHMuaW5saW5lXG4gICAgICAgID8gaW5saW5lRGVmYXVsdHNcbiAgICAgICAgOiBkZWZhdWx0RXh0ZW5kZWRJY29uQ3VzdG9taXNhdGlvbnM7XG4gICAgLy8gR2V0IGFsbCBjdXN0b21pc2F0aW9uc1xuICAgIGNvbnN0IGN1c3RvbWlzYXRpb25zID0gbWVyZ2VDdXN0b21pc2F0aW9ucyhkZWZhdWx0UHJvcHMsIHByb3BzKTtcbiAgICAvLyBDaGVjayBtb2RlXG4gICAgY29uc3QgbW9kZSA9IHByb3BzLm1vZGUgfHwgJ3N2Zyc7XG4gICAgLy8gQ3JlYXRlIHN0eWxlXG4gICAgY29uc3Qgc3R5bGUgPSB7fTtcbiAgICBjb25zdCBjdXN0b21TdHlsZSA9IHByb3BzLnN0eWxlIHx8IHt9O1xuICAgIC8vIENyZWF0ZSBTVkcgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICBjb25zdCBjb21wb25lbnRQcm9wcyA9IHtcbiAgICAgICAgLi4uKG1vZGUgPT09ICdzdmcnID8gc3ZnRGVmYXVsdHMgOiB7fSksXG4gICAgfTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBjb25zdCBpY29uTmFtZSA9IHN0cmluZ1RvSWNvbihuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChpY29uTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFsnaWNvbmlmeSddO1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgICAgICAgICAgJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICAncHJlZml4JyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWNvbk5hbWVbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdpY29uaWZ5LS0nICsgaWNvbk5hbWVbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudFByb3BzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdldCBlbGVtZW50IHByb3BlcnRpZXNcbiAgICBmb3IgKGxldCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgdG8gaWdub3JlXG4gICAgICAgICAgICBjYXNlICdpY29uJzpcbiAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICAgIGNhc2UgJ29uTG9hZCc6XG4gICAgICAgICAgICBjYXNlICdtb2RlJzpcbiAgICAgICAgICAgIGNhc2UgJ3Nzcic6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIHJlZlxuICAgICAgICAgICAgY2FzZSAnX3JlZic6XG4gICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcHMucmVmID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBNZXJnZSBjbGFzcyBuYW1lc1xuICAgICAgICAgICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgICAgICAgICAgICBjb21wb25lbnRQcm9wc1trZXldID1cbiAgICAgICAgICAgICAgICAgICAgKGNvbXBvbmVudFByb3BzW2tleV0gPyBjb21wb25lbnRQcm9wc1trZXldICsgJyAnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQm9vbGVhbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBjYXNlICdpbmxpbmUnOlxuICAgICAgICAgICAgY2FzZSAnaEZsaXAnOlxuICAgICAgICAgICAgY2FzZSAndkZsaXAnOlxuICAgICAgICAgICAgICAgIGN1c3RvbWlzYXRpb25zW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gRmxpcCBhcyBzdHJpbmc6ICdob3Jpem9udGFsLHZlcnRpY2FsJ1xuICAgICAgICAgICAgY2FzZSAnZmxpcCc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxpcEZyb21TdHJpbmcoY3VzdG9taXNhdGlvbnMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBDb2xvcjogY29weSB0byBzdHlsZVxuICAgICAgICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICAgICAgICAgIHN0eWxlLmNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBSb3RhdGlvbiBhcyBzdHJpbmdcbiAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9taXNhdGlvbnNba2V5XSA9IHJvdGF0ZUZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWlzYXRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYXJpYS1oaWRkZW5cbiAgICAgICAgICAgIGNhc2UgJ2FyaWFIaWRkZW4nOlxuICAgICAgICAgICAgY2FzZSAnYXJpYS1oaWRkZW4nOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSAmJiB2YWx1ZSAhPT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnRQcm9wc1snYXJpYS1oaWRkZW4nXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBDb3B5IG1pc3NpbmcgcHJvcGVydHkgaWYgaXQgZG9lcyBub3QgZXhpc3QgaW4gY3VzdG9taXNhdGlvbnNcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRQcm9wc1trZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcHNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSBpY29uXG4gICAgY29uc3QgaXRlbSA9IGljb25Ub1NWRyhpY29uLCBjdXN0b21pc2F0aW9ucyk7XG4gICAgY29uc3QgcmVuZGVyQXR0cmlicyA9IGl0ZW0uYXR0cmlidXRlcztcbiAgICAvLyBJbmxpbmUgZGlzcGxheVxuICAgIGlmIChjdXN0b21pc2F0aW9ucy5pbmxpbmUpIHtcbiAgICAgICAgc3R5bGUudmVydGljYWxBbGlnbiA9ICctMC4xMjVlbSc7XG4gICAgfVxuICAgIGlmIChtb2RlID09PSAnc3ZnJykge1xuICAgICAgICAvLyBBZGQgc3R5bGVcbiAgICAgICAgY29tcG9uZW50UHJvcHMuc3R5bGUgPSB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIC4uLmN1c3RvbVN0eWxlLFxuICAgICAgICB9O1xuICAgICAgICAvLyBBZGQgaWNvbiBzdHVmZlxuICAgICAgICBPYmplY3QuYXNzaWduKGNvbXBvbmVudFByb3BzLCByZW5kZXJBdHRyaWJzKTtcbiAgICAgICAgLy8gQ291bnRlciBmb3IgaWRzIGJhc2VkIG9uIFwiaWRcIiBwcm9wZXJ0eSB0byByZW5kZXIgaWNvbnMgY29uc2lzdGVudGx5IG9uIHNlcnZlciBhbmQgY2xpZW50XG4gICAgICAgIGxldCBsb2NhbENvdW50ZXIgPSAwO1xuICAgICAgICBsZXQgaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgJy0nIHRvICdfJyB0byBhdm9pZCBlcnJvcnMgaW4gYW5pbWF0aW9uc1xuICAgICAgICAgICAgaWQgPSBpZC5yZXBsYWNlKC8tL2csICdfJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGljb24gc3R1ZmZcbiAgICAgICAgY29tcG9uZW50UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7XG4gICAgICAgICAgICBfX2h0bWw6IGNsZWFuVXBJbm5lckhUTUwocmVwbGFjZUlEcyhpdGVtLmJvZHksIGlkID8gKCkgPT4gaWQgKyAnSUQnICsgbG9jYWxDb3VudGVyKysgOiAnaWNvbmlmeVJlYWN0JykpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnc3ZnJywgY29tcG9uZW50UHJvcHMpO1xuICAgIH1cbiAgICAvLyBSZW5kZXIgPHNwYW4+IHdpdGggc3R5bGVcbiAgICBjb25zdCB7IGJvZHksIHdpZHRoLCBoZWlnaHQgfSA9IGljb247XG4gICAgY29uc3QgdXNlTWFzayA9IG1vZGUgPT09ICdtYXNrJyB8fFxuICAgICAgICAobW9kZSA9PT0gJ2JnJyA/IGZhbHNlIDogYm9keS5pbmRleE9mKCdjdXJyZW50Q29sb3InKSAhPT0gLTEpO1xuICAgIC8vIEdlbmVyYXRlIFNWR1xuICAgIGNvbnN0IGh0bWwgPSBpY29uVG9IVE1MKGJvZHksIHtcbiAgICAgICAgLi4ucmVuZGVyQXR0cmlicyxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgJycsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgJycsXG4gICAgfSk7XG4gICAgLy8gR2VuZXJhdGUgc3R5bGVcbiAgICBjb21wb25lbnRQcm9wcy5zdHlsZSA9IHtcbiAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICctLXN2Zyc6IHN2Z1RvVVJMKGh0bWwpLFxuICAgICAgICAnd2lkdGgnOiBmaXhTaXplKHJlbmRlckF0dHJpYnMud2lkdGgpLFxuICAgICAgICAnaGVpZ2h0JzogZml4U2l6ZShyZW5kZXJBdHRyaWJzLmhlaWdodCksXG4gICAgICAgIC4uLmNvbW1vblByb3BzLFxuICAgICAgICAuLi4odXNlTWFzayA/IG1vbm90b25lUHJvcHMgOiBjb2xvcmVkUHJvcHMpLFxuICAgICAgICAuLi5jdXN0b21TdHlsZSxcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdzcGFuJywgY29tcG9uZW50UHJvcHMpO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXNlIHN0dWZmXG4gKi9cbi8vIEVuYWJsZSBzaG9ydCBuYW1lc1xuYWxsb3dTaW1wbGVOYW1lcyh0cnVlKTtcbi8vIFNldCBBUEkgbW9kdWxlXG5zZXRBUElNb2R1bGUoJycsIGZldGNoQVBJTW9kdWxlKTtcbi8qKlxuICogQnJvd3NlciBzdHVmZlxuICovXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IF93aW5kb3cgPSB3aW5kb3c7XG4gICAgLy8gTG9hZCBpY29ucyBmcm9tIGdsb2JhbCBcIkljb25pZnlQcmVsb2FkXCJcbiAgICBpZiAoX3dpbmRvdy5JY29uaWZ5UHJlbG9hZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHByZWxvYWQgPSBfd2luZG93Lkljb25pZnlQcmVsb2FkO1xuICAgICAgICBjb25zdCBlcnIgPSAnSW52YWxpZCBJY29uaWZ5UHJlbG9hZCBzeW50YXguJztcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVsb2FkID09PSAnb2JqZWN0JyAmJiBwcmVsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAocHJlbG9hZCBpbnN0YW5jZW9mIEFycmF5ID8gcHJlbG9hZCA6IFtwcmVsb2FkXSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXRlbSBpcyBhbiBvYmplY3QgYW5kIG5vdCBudWxsL2FycmF5XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgJ2ljb25zJyBhbmQgJ3ByZWZpeCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtLmljb25zICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0ucHJlZml4ICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGljb24gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAhYWRkQ29sbGVjdGlvbihpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgQVBJIGZyb20gZ2xvYmFsIFwiSWNvbmlmeVByb3ZpZGVyc1wiXG4gICAgaWYgKF93aW5kb3cuSWNvbmlmeVByb3ZpZGVycyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IF93aW5kb3cuSWNvbmlmeVByb3ZpZGVycztcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcnMgPT09ICdvYmplY3QnICYmIHByb3ZpZGVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9ICdJY29uaWZ5UHJvdmlkZXJzWycgKyBrZXkgKyAnXSBpcyBpbnZhbGlkLic7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm92aWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICF2YWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucmVzb3VyY2VzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWRkQVBJUHJvdmlkZXIoa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gSWNvbkNvbXBvbmVudChwcm9wcykge1xuICAgIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IHVzZVN0YXRlKCEhcHJvcHMuc3NyKTtcbiAgICBjb25zdCBbYWJvcnQsIHNldEFib3J0XSA9IHVzZVN0YXRlKHt9KTtcbiAgICAvLyBHZXQgaW5pdGlhbCBzdGF0ZVxuICAgIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShtb3VudGVkKSB7XG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gcHJvcHMuaWNvbjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBJY29uIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBuYW1lLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZ2V0SWNvbkRhdGEobmFtZSk7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoZ2V0SW5pdGlhbFN0YXRlKCEhcHJvcHMuc3NyKSk7XG4gICAgLy8gQ2FuY2VsIGxvYWRpbmdcbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGFib3J0LmNhbGxiYWNrO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBzZXRBYm9ydCh7fSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hhbmdlIHN0YXRlIGlmIGl0IGlzIGRpZmZlcmVudFxuICAgIGZ1bmN0aW9uIGNoYW5nZVN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShzdGF0ZSkgIT09IEpTT04uc3RyaW5naWZ5KG5ld1N0YXRlKSkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgZnVuY3Rpb24gdXBkYXRlU3RhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHByb3BzLmljb247XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIEljb24gYXMgb2JqZWN0XG4gICAgICAgICAgICBjaGFuZ2VTdGF0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgZGF0YTogbmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5ldyBpY29uIG9yIGdvdCBpY29uIGRhdGFcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEljb25EYXRhKG5hbWUpO1xuICAgICAgICBpZiAoY2hhbmdlU3RhdGUoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZCBpY29uLCB1cGRhdGUgc3RhdGUgd2hlbiBkb25lXG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBsb2FkSWNvbnMoW25hbWVdLCB1cGRhdGVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgc2V0QWJvcnQoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBJY29uIGRhdGEgaXMgYXZhaWxhYmxlOiB0cmlnZ2VyIG9uTG9hZCBjYWxsYmFjayBpZiBwcmVzZW50XG4gICAgICAgICAgICAgICAgKF9hID0gcHJvcHMub25Mb2FkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChwcm9wcywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTW91bnRlZCBzdGF0ZSwgY2xlYW51cCBmb3IgbG9hZGVyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgfSwgW10pO1xuICAgIC8vIEljb24gY2hhbmdlZCBvciBjb21wb25lbnQgbW91bnRlZFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSwgW3Byb3BzLmljb24sIG1vdW50ZWRdKTtcbiAgICAvLyBSZW5kZXIgaWNvblxuICAgIGNvbnN0IHsgbmFtZSwgZGF0YSB9ID0gc3RhdGU7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgPyBwcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgOiBwcm9wcy5mYWxsYmFja1xuICAgICAgICAgICAgICAgID8gcHJvcHMuZmFsbGJhY2tcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7fSk7XG4gICAgfVxuICAgIHJldHVybiByZW5kZXIoe1xuICAgICAgICAuLi5kZWZhdWx0SWNvblByb3BzLFxuICAgICAgICAuLi5kYXRhLFxuICAgIH0sIHByb3BzLCBuYW1lKTtcbn1cbi8qKlxuICogQmxvY2sgaWNvblxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIENvbXBvbmVudCBwcm9wZXJ0aWVzXG4gKi9cbmNvbnN0IEljb24gPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiBJY29uQ29tcG9uZW50KHtcbiAgICAuLi5wcm9wcyxcbiAgICBfcmVmOiByZWYsXG59KSk7XG4vKipcbiAqIElubGluZSBpY29uIChoYXMgbmVnYXRpdmUgdmVydGljYWxBbGlnbiB0aGF0IG1ha2VzIGl0IGJlaGF2ZSBsaWtlIGljb24gZm9udClcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBDb21wb25lbnQgcHJvcGVydGllc1xuICovXG5jb25zdCBJbmxpbmVJY29uID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gSWNvbkNvbXBvbmVudCh7XG4gICAgaW5saW5lOiB0cnVlLFxuICAgIC4uLnByb3BzLFxuICAgIF9yZWY6IHJlZixcbn0pKTtcbi8qKlxuICogSW50ZXJuYWwgQVBJXG4gKi9cbmNvbnN0IF9hcGkgPSB7XG4gICAgZ2V0QVBJQ29uZmlnLFxuICAgIHNldEFQSU1vZHVsZSxcbiAgICBzZW5kQVBJUXVlcnksXG4gICAgc2V0RmV0Y2gsXG4gICAgZ2V0RmV0Y2gsXG4gICAgbGlzdEFQSVByb3ZpZGVycyxcbn07XG5cbmV4cG9ydCB7IEljb24sIElubGluZUljb24sIF9hcGksIGFkZEFQSVByb3ZpZGVyLCBhZGRDb2xsZWN0aW9uLCBhZGRJY29uLCBpY29uVG9TVkcgYXMgYnVpbGRJY29uLCBjYWxjdWxhdGVTaXplLCBnZXRJY29uLCBpY29uTG9hZGVkLCBsaXN0SWNvbnMsIGxvYWRJY29uLCBsb2FkSWNvbnMsIHJlcGxhY2VJRHMsIHNldEN1c3RvbUljb25Mb2FkZXIsIHNldEN1c3RvbUljb25zTG9hZGVyIH07XG4iXSwibmFtZXMiOlsiY3JlYXRlRWxlbWVudCIsImZvcndhcmRSZWYiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImRlZmF1bHRJY29uRGltZW5zaW9ucyIsIk9iamVjdCIsImZyZWV6ZSIsImxlZnQiLCJ0b3AiLCJ3aWR0aCIsImhlaWdodCIsImRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zIiwicm90YXRlIiwidkZsaXAiLCJoRmxpcCIsImRlZmF1bHRJY29uUHJvcHMiLCJkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHMiLCJib2R5IiwiaGlkZGVuIiwibWVyZ2VJY29uVHJhbnNmb3JtYXRpb25zIiwib2JqMSIsIm9iajIiLCJyZXN1bHQiLCJtZXJnZUljb25EYXRhIiwicGFyZW50IiwiY2hpbGQiLCJrZXkiLCJnZXRJY29uc1RyZWUiLCJkYXRhIiwibmFtZXMiLCJpY29ucyIsImFsaWFzZXMiLCJjcmVhdGUiLCJyZXNvbHZlZCIsInJlc29sdmUiLCJuYW1lIiwidmFsdWUiLCJjb25jYXQiLCJrZXlzIiwiZm9yRWFjaCIsImludGVybmFsR2V0SWNvbkRhdGEiLCJ0cmVlIiwiY3VycmVudFByb3BzIiwicGFyc2UiLCJuYW1lMiIsInBhcnNlSWNvblNldCIsImNhbGxiYWNrIiwibm90X2ZvdW5kIiwiQXJyYXkiLCJwdXNoIiwiaXRlbSIsIm9wdGlvbmFsUHJvcGVydHlEZWZhdWx0cyIsInByb3ZpZGVyIiwiY2hlY2tPcHRpb25hbFByb3BzIiwiZGVmYXVsdHMiLCJwcm9wIiwicXVpY2tseVZhbGlkYXRlSWNvblNldCIsIm9iaiIsInByZWZpeCIsImljb24iLCJtYXRjaEljb25OYW1lIiwic3RyaW5nVG9JY29uIiwidmFsaWRhdGUiLCJhbGxvd1NpbXBsZU5hbWUiLCJjb2xvblNlcGFyYXRlZCIsInNwbGl0Iiwic2xpY2UiLCJsZW5ndGgiLCJzaGlmdCIsInBvcCIsInZhbGlkYXRlSWNvbk5hbWUiLCJkYXNoU2VwYXJhdGVkIiwiam9pbiIsImRhdGFTdG9yYWdlIiwibmV3U3RvcmFnZSIsIm1pc3NpbmciLCJTZXQiLCJnZXRTdG9yYWdlIiwicHJvdmlkZXJTdG9yYWdlIiwiYWRkSWNvblNldCIsInN0b3JhZ2UiLCJhZGQiLCJhZGRJY29uVG9TdG9yYWdlIiwiZXJyIiwibGlzdEljb25zIiwiYWxsSWNvbnMiLCJwcm92aWRlcnMiLCJwcm92aWRlcjIiLCJwcmVmaXhlcyIsInByZWZpeDIiLCJtYXAiLCJzaW1wbGVOYW1lcyIsImFsbG93U2ltcGxlTmFtZXMiLCJhbGxvdyIsImdldEljb25EYXRhIiwiaWNvbk5hbWUiLCJoYXMiLCJhZGRJY29uIiwiYWRkQ29sbGVjdGlvbiIsImFkZGVkIiwiaWNvbkxvYWRlZCIsImdldEljb24iLCJkZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucyIsImRlZmF1bHRJY29uQ3VzdG9taXNhdGlvbnMiLCJ1bml0c1NwbGl0IiwidW5pdHNUZXN0IiwiY2FsY3VsYXRlU2l6ZSIsInNpemUiLCJyYXRpbyIsInByZWNpc2lvbiIsIk1hdGgiLCJjZWlsIiwib2xkUGFydHMiLCJuZXdQYXJ0cyIsImNvZGUiLCJpc051bWJlciIsInRlc3QiLCJudW0iLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJzcGxpdFNWR0RlZnMiLCJjb250ZW50IiwidGFnIiwiZGVmcyIsImluZGV4IiwiaW5kZXhPZiIsInN0YXJ0IiwiZW5kIiwiZW5kRW5kIiwidHJpbSIsIm1lcmdlRGVmc0FuZENvbnRlbnQiLCJ3cmFwU1ZHQ29udGVudCIsImlzVW5zZXRLZXl3b3JkIiwiaWNvblRvU1ZHIiwiY3VzdG9taXNhdGlvbnMiLCJmdWxsSWNvbiIsImZ1bGxDdXN0b21pc2F0aW9ucyIsImJveCIsInByb3BzIiwidHJhbnNmb3JtYXRpb25zIiwicm90YXRpb24iLCJ0b1N0cmluZyIsInRlbXBWYWx1ZSIsImZsb29yIiwidW5zaGlmdCIsImN1c3RvbWlzYXRpb25zV2lkdGgiLCJjdXN0b21pc2F0aW9uc0hlaWdodCIsImJveFdpZHRoIiwiYm94SGVpZ2h0IiwiYXR0cmlidXRlcyIsInNldEF0dHIiLCJ2aWV3Qm94IiwicmVnZXgiLCJyYW5kb21QcmVmaXgiLCJEYXRlIiwibm93IiwicmFuZG9tIiwiY291bnRlciIsInJlcGxhY2VJRHMiLCJpZHMiLCJtYXRjaCIsImV4ZWMiLCJzdWZmaXgiLCJpZCIsIm5ld0lEIiwiZXNjYXBlZElEIiwicmVwbGFjZSIsIlJlZ0V4cCIsInNldEFQSU1vZHVsZSIsImdldEFQSU1vZHVsZSIsImNyZWF0ZUFQSUNvbmZpZyIsInNvdXJjZSIsInJlc291cmNlcyIsInBhdGgiLCJtYXhVUkwiLCJ0aW1lb3V0IiwiZGF0YUFmdGVyVGltZW91dCIsImNvbmZpZ1N0b3JhZ2UiLCJmYWxsQmFja0FQSVNvdXJjZXMiLCJmYWxsQmFja0FQSSIsImFkZEFQSVByb3ZpZGVyIiwiY3VzdG9tQ29uZmlnIiwiY29uZmlnIiwiZ2V0QVBJQ29uZmlnIiwibGlzdEFQSVByb3ZpZGVycyIsImRldGVjdEZldGNoIiwiZmV0Y2giLCJmZXRjaE1vZHVsZSIsInNldEZldGNoIiwiZmV0Y2gyIiwiZ2V0RmV0Y2giLCJjYWxjdWxhdGVNYXhMZW5ndGgiLCJtYXhIb3N0TGVuZ3RoIiwiaG9zdCIsIm1heCIsInVybCIsInNob3VsZEFib3J0Iiwic3RhdHVzIiwicHJlcGFyZSIsInJlc3VsdHMiLCJtYXhMZW5ndGgiLCJ0eXBlIiwiZ2V0UGF0aCIsInNlbmQiLCJwYXJhbXMiLCJpY29uc0xpc3QiLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ1cmkiLCJkZWZhdWx0RXJyb3IiLCJ0aGVuIiwicmVzcG9uc2UiLCJzZXRUaW1lb3V0IiwianNvbiIsImNhdGNoIiwiZmV0Y2hBUElNb2R1bGUiLCJzb3J0SWNvbnMiLCJsb2FkZWQiLCJwZW5kaW5nIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImxhc3RJY29uIiwibG9jYWxTdG9yYWdlIiwibGlzdCIsInJlbW92ZUNhbGxiYWNrIiwic3RvcmFnZXMiLCJpdGVtcyIsImxvYWRlckNhbGxiYWNrcyIsImZpbHRlciIsInJvdyIsInVwZGF0ZUNhbGxiYWNrcyIsInBlbmRpbmdDYWxsYmFja3NGbGFnIiwiaGFzUGVuZGluZyIsIm9sZExlbmd0aCIsImFib3J0IiwiaWRDb3VudGVyIiwic3RvcmVDYWxsYmFjayIsInBlbmRpbmdTb3VyY2VzIiwiYmluZCIsImxpc3RUb0ljb25zIiwiZGVmYXVsdENvbmZpZyIsInNlbmRRdWVyeSIsInBheWxvYWQiLCJxdWVyeSIsImRvbmUiLCJyZXNvdXJjZXNDb3VudCIsInN0YXJ0SW5kZXgiLCJuZXh0SW5kZXgiLCJzdGFydFRpbWUiLCJxdWVyaWVzU2VudCIsImxhc3RFcnJvciIsInRpbWVyIiwicXVldWUiLCJkb25lQ2FsbGJhY2tzIiwicmVzZXRUaW1lciIsImNsZWFyVGltZW91dCIsInN1YnNjcmliZSIsIm92ZXJ3cml0ZSIsImdldFF1ZXJ5U3RhdHVzIiwicXVlcmllc1BlbmRpbmciLCJmYWlsUXVlcnkiLCJjbGVhclF1ZXVlIiwibW9kdWxlUmVzcG9uc2UiLCJpc0Vycm9yIiwicXVldWVkIiwiZXhlY05leHQiLCJyZXNvdXJjZSIsInN0YXR1czIiLCJpbml0UmVkdW5kYW5jeSIsImNmZyIsInF1ZXJpZXMiLCJjbGVhbnVwIiwicXVlcnlDYWxsYmFjayIsImRvbmVDYWxsYmFjayIsInF1ZXJ5MiIsImVycm9yIiwiZmluZCIsImluc3RhbmNlIiwic2V0SW5kZXgiLCJnZXRJbmRleCIsImVtcHR5Q2FsbGJhY2skMSIsInJlZHVuZGFuY3lDYWNoZSIsImdldFJlZHVuZGFuY3lDYWNoZSIsInJlZHVuZGFuY3kiLCJjYWNoZWRSZXVuZGFuY3kiLCJzZW5kQVBJUXVlcnkiLCJ0YXJnZXQiLCJhcGkiLCJjYWNoZWQiLCJtb2R1bGVLZXkiLCJlbXB0eUNhbGxiYWNrIiwibG9hZGVkTmV3SWNvbnMiLCJpY29uc0xvYWRlckZsYWciLCJjaGVja0ljb25OYW1lc0ZvckFQSSIsInZhbGlkIiwiaW52YWxpZCIsInBhcnNlTG9hZGVyUmVzcG9uc2UiLCJjaGVja01pc3NpbmciLCJwZW5kaW5nSWNvbnMiLCJkZWxldGUiLCJwYXJzZWQiLCJjb25zb2xlIiwicGFyc2VQb3NzaWJseUFzeW5jUmVzcG9uc2UiLCJQcm9taXNlIiwibG9hZE5ld0ljb25zIiwiaWNvbnNUb0xvYWQiLCJpY29uc1F1ZXVlRmxhZyIsImljb25zMiIsImN1c3RvbUljb25Mb2FkZXIiLCJsb2FkSWNvbiIsImxvYWRJY29ucyIsImljb25TZXQiLCJjbGVhbmVkSWNvbnMiLCJzb3J0ZWRJY29ucyIsImNhbGxDYWxsYmFjayIsIm5ld0ljb25zIiwic291cmNlcyIsImxhc3RQcm92aWRlciIsImxhc3RQcmVmaXgiLCJwcm92aWRlck5ld0ljb25zIiwicGVuZGluZ1F1ZXVlIiwiZnVsZmlsbCIsInJlamVjdCIsImljb25PYmoiLCJzZXRDdXN0b21JY29uc0xvYWRlciIsImxvYWRlciIsInNldEN1c3RvbUljb25Mb2FkZXIiLCJtZXJnZUN1c3RvbWlzYXRpb25zIiwidmFsdWVUeXBlIiwic2VwYXJhdG9yIiwiZmxpcEZyb21TdHJpbmciLCJjdXN0b20iLCJmbGlwIiwic3RyIiwicm90YXRlRnJvbVN0cmluZyIsImRlZmF1bHRWYWx1ZSIsInVuaXRzIiwidmFsdWUyIiwicGFyc2VJbnQiLCJpY29uVG9IVE1MIiwicmVuZGVyQXR0cmlic0hUTUwiLCJhdHRyIiwiZW5jb2RlU1ZHZm9yVVJMIiwic3ZnIiwic3ZnVG9EYXRhIiwic3ZnVG9VUkwiLCJwb2xpY3kiLCJjcmVhdGVQb2xpY3kiLCJ3aW5kb3ciLCJ0cnVzdGVkVHlwZXMiLCJjcmVhdGVIVE1MIiwicyIsImNsZWFuVXBJbm5lckhUTUwiLCJodG1sIiwiZGVmYXVsdEV4dGVuZGVkSWNvbkN1c3RvbWlzYXRpb25zIiwiaW5saW5lIiwic3ZnRGVmYXVsdHMiLCJjb21tb25Qcm9wcyIsImRpc3BsYXkiLCJtb25vdG9uZVByb3BzIiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3JlZFByb3BzIiwicHJvcHNUb0FkZCIsIkltYWdlIiwiUmVwZWF0IiwiU2l6ZSIsInByb3BzVG9BZGRUbyIsIldlYmtpdE1hc2siLCJtYXNrIiwiYmFja2dyb3VuZCIsImlubGluZURlZmF1bHRzIiwiZml4U2l6ZSIsInJlbmRlciIsImRlZmF1bHRQcm9wcyIsIm1vZGUiLCJzdHlsZSIsImN1c3RvbVN0eWxlIiwiY29tcG9uZW50UHJvcHMiLCJjbGFzc05hbWVzIiwiY2xhc3NOYW1lIiwicmVmIiwiY29sb3IiLCJyZW5kZXJBdHRyaWJzIiwidmVydGljYWxBbGlnbiIsImFzc2lnbiIsImxvY2FsQ291bnRlciIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwidXNlTWFzayIsImRvY3VtZW50IiwiX3dpbmRvdyIsIkljb25pZnlQcmVsb2FkIiwicHJlbG9hZCIsImUiLCJJY29uaWZ5UHJvdmlkZXJzIiwiSWNvbkNvbXBvbmVudCIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwic3NyIiwic2V0QWJvcnQiLCJnZXRJbml0aWFsU3RhdGUiLCJzdGF0ZSIsInNldFN0YXRlIiwiY2hhbmdlU3RhdGUiLCJuZXdTdGF0ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1cGRhdGVTdGF0ZSIsIl9hIiwidW5kZWZpbmVkIiwib25Mb2FkIiwiY2FsbCIsImNoaWxkcmVuIiwiZmFsbGJhY2siLCJJY29uIiwiX3JlZiIsIklubGluZUljb24iLCJfYXBpIiwiYnVpbGRJY29uIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@iconify/react/dist/iconify.js\n");

/***/ })

};
;